"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
require("rxjs/Rx");
var GenericTableComponent = (function () {
    function GenericTableComponent() {
        var _this = this;
        this.sortOrder = [];
        this.metaInfo = {};
        this.selectedRows = [];
        this.openRows = [];
        this.gtDefaultTexts = {
            loading: "Loading...",
            noData: "No data",
            noMatchingData: "No data matching results found",
            noVisibleColumnsHeading: "No visible columns",
            noVisibleColumns: "Please select at least one column to be visible.",
            tableInfo: "Showing #recordFrom to #recordTo of #recordsAfterSearch entries.",
            tableInfoAfterSearch: "Showing  #recordFrom to #recordTo of #recordsAfterSearch entries (filtered from a total of #recordsAll entries).",
            csvDownload: "download",
            sortLabel: "Sort:",
            paginateNext: "Next page",
            paginatePrevious: "Previous page"
        };
        this.gtTexts = this.gtDefaultTexts;
        this.gtEvent = new core_1.EventEmitter();
        this.gtDefaultOptions = {
            csvDelimiter: ';',
            stack: false,
            lazyLoad: false,
            cache: false,
            debounceTime: 200,
            highlightSearch: false,
            rowSelection: false
        };
        this.gtOptions = this.gtDefaultOptions;
        this.store = [];
        this.loading = true;
        this.debounceTimer = null;
        this.gtInfo = {
            pageCurrent: 1,
            pageTotal: 0,
            recordFrom: 0,
            recordTo: 0,
            recordLength: 10,
            recordsAll: 0,
            recordsAfterFilter: 0,
            recordsAfterSearch: 0
        };
        this.refreshPipe = false;
        this.refreshSorting = false;
        /**
         * Sort table by object key.
         * @param {string} objectKey - name of key to sort on.
         * @param {any} event - such as key press during sorting.
         */
        this.gtSort = function (objectKey, event) {
            //console.log('key pressed:',objectKey,event.metaKey);
            // check if sorting is disabled
            for (var i = 0; i < this.gtSettings.length; i++) {
                if (this.gtSettings[i].objectKey === objectKey) {
                    if (this.gtSettings[i].sort === 'disable') {
                        return;
                    }
                }
            }
            // check length
            var ctrlKey = event.metaKey || event.ctrlKey;
            var sort = this.sortOrder.slice(0);
            var match = -1;
            var matchDesc = -1;
            var pos = -1;
            // check if property already exits
            for (var i = 0; i < sort.length; i++) {
                var hit = sort[i].indexOf(objectKey);
                //console.log('match:',sort[i],objectKey,match,hit);
                if (hit !== -1) {
                    //console.log('MATCH',this.sortOrder,objectKey);
                    match = this.sortOrder.indexOf(objectKey);
                    matchDesc = match === -1 ? this.sortOrder.indexOf('-' + objectKey) : match;
                    pos = Math.max(match, matchDesc);
                }
            }
            // if ctrl key or meta key is press together with sort...
            if (ctrlKey) {
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...add property to sorting
                        this.sortOrder.push(objectKey);
                        break;
                    default:
                        // ...and property is sorted before...
                        if (match !== -1) {
                            // ...change from asc to desc if sorted asc
                            this.sortOrder[pos] = '-' + objectKey;
                        }
                        else if (this.sortOrder.length > 1) {
                            // ...remove sorting if sorted desc
                            this.sortOrder.splice(pos, 1);
                        }
                        else if (this.sortOrder.length === 1) {
                            // ...set sorting to asc if only sorted property
                            this.sortOrder[pos] = objectKey;
                        }
                        break;
                }
            }
            else {
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...sort by property
                        this.sortOrder = [objectKey];
                        break;
                    default:
                        // ...change from desc to asc and vise versa
                        this.sortOrder = match !== -1 ? ['-' + objectKey] : [objectKey];
                        break;
                }
            }
            // update settings object with new sorting information
            for (var i = 0; i < this.gtSettings.length; i++) {
                if (this.gtSettings[i].objectKey === objectKey) {
                    switch (this.gtSettings[i].sort) {
                        // if sorted asc...
                        case 'asc':
                            // ...change to desc
                            this.gtSettings[i].sort = 'desc';
                            break;
                        // if sorted desc...
                        case 'desc':
                            // ...change to asc if it's the only sorted property otherwise remove sorting
                            this.gtSettings[i].sort = this.sortOrder.length === 1 && sort.length < 2 ? 'asc' : 'enable';
                            break;
                        // if sorting enabled...
                        case 'enable':
                            // ...change to asc
                            this.gtSettings[i].sort = 'asc';
                            break;
                    }
                    this.gtSettings[i].sortOrder = this.gtSettings[i].sort === 'enable' ? (this.gtSettings.length - 1) : this.sortOrder.indexOf(objectKey) === -1 ? this.sortOrder.indexOf('-' + objectKey) : this.sortOrder.indexOf(objectKey);
                }
                else if (this.gtSettings[i].sort !== 'disable' && this.sortOrder.indexOf(this.gtSettings[i].objectKey) === -1 && this.sortOrder.indexOf('-' + this.gtSettings[i].objectKey) === -1) {
                    this.gtSettings[i].sort = 'enable';
                    this.gtSettings[i].sortOrder = (this.gtSettings.length - 1);
                }
            }
            // refresh sorting pipe
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            // emit sort event
            this.gtEvent.emit({
                name: 'gt-sorting-applied',
                value: this.sortOrder
            });
        };
        /**
         * Change number of rows to be displayed.
         * @param {string} rowLength - total number of rows.
         * @param {boolean} reset - should page be reset to first page.
         * @returns {number} number of pages to display.
         */
        this.changeRowLength = function (rowLength, reset) {
            //console.log('change rows');
            var newPosition = 1;
            // if reset is not true and we're not lazy loading data...
            if (reset !== true && this.gtOptions.lazyLoad !== true) {
                // ...get current position in record set
                var currentRecord = this.gtInfo.recordLength * (this.gtInfo.pageCurrent - 1);
                var currentPosition = this.gtData.indexOf(this.gtData[currentRecord]) + 1;
                // ...get new position
                newPosition = Math.ceil(currentPosition / rowLength);
            }
            // change row length
            this.gtInfo.recordLength = parseInt(rowLength);
            // go to new position
            this.gtInfo.pageCurrent = newPosition;
            // if lazy loading data...
            if (this.gtOptions.lazyLoad) {
                // ...replace data with place holders for new data
                this.gtData[0] = this.loadingContent(rowLength);
                // ...empty current store
                this.store = [];
            }
            //this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-row-length-changed',
                value: rowLength
            });
        };
        /**
         * Force a redraw of table rows.
         * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
         */
        this.redraw = function () {
            this.refreshPipe = !this.refreshPipe;
        };
        /** Update record range. */
        this.updateRecordRange = function () {
            this.gtInfo.recordFrom = this.gtInfo.recordsAfterSearch === 0 ? 0 : (this.gtInfo.pageCurrent - 1) * this.gtInfo.recordLength + 1;
            this.gtInfo.recordTo = this.gtInfo.recordsAfterSearch < this.gtInfo.pageCurrent * this.gtInfo.recordLength ? this.gtInfo.recordsAfterSearch : this.gtInfo.pageCurrent * this.gtInfo.recordLength;
            //this._changeDetectionRef.detectChanges();
        };
        /** Go to next page. */
        this.nextPage = function () {
            var page = this.gtInfo.pageCurrent === this.gtInfo.pageTotal ? this.gtInfo.pageTotal : this.gtInfo.pageCurrent += 1;
            this.goToPage(page);
            // prevent browser reload
            //event.preventDefault();
        };
        /** Go to previous page. */
        this.previousPage = function () {
            var page = this.gtInfo.pageCurrent === 1 ? 1 : this.gtInfo.pageCurrent -= 1;
            this.goToPage(page);
            // prevent browser reload
            //event.preventDefault();
        };
        /** Request more data (used when lazy loading) */
        this.getData = function () {
            // ...emit event requesting for more data
            this.gtEvent.emit({
                name: 'gt-page-changed-lazy',
                value: { pageCurrent: this.gtInfo.pageCurrent, recordLength: this.gtInfo.recordLength }
            });
        };
        /**
         * Go to specific page.
         * @param {number} page - page number.
         */
        this.goToPage = function (page) {
            var _this = this;
            this.gtInfo.pageCurrent = page;
            // if lazy loading and if page contains no records...
            if (this.gtOptions.lazyLoad) {
                // ...if data for current page contains no entries...
                if (this.gtOptions.cache === false || this.gtData[this.gtInfo.pageCurrent - 1].length === 0) {
                    // ...create temporary content while waiting for data
                    this.gtData[this.gtInfo.pageCurrent - 1] = this.loadingContent(this.gtInfo.recordLength);
                    this.loading = true; // loading true
                }
                // ...if first entry in current page equals our loading placeholder...
                if (this.gtData[this.gtInfo.pageCurrent - 1][0][this.loadingProperty] === this.gtTexts.loading) {
                    // ...get data
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(function () {
                        _this.getData();
                    }, this.gtOptions.debounceTime);
                }
            }
            //this.updateRecordRange();
            // ...emit page change event
            this.gtEvent.emit({
                name: 'gt-page-changed',
                value: { pageCurrent: this.gtInfo.pageCurrent, recordLength: this.gtInfo.recordLength }
            });
        };
        /**
         * Apply filter(s).
         * @param {Object} filter - object containing key value pairs, where value should be array of values.
         */
        this.gtApplyFilter = function (filter) {
            this.gtInfo.filter = filter;
            // go to first page
            this.goToPage(1);
        };
        /** Clear/remove applied filter(s). */
        this.gtClearFilter = function () {
            this.gtInfo.filter = false;
            //this.updateRecordRange();
        };
        /**
         * Search
         * @param {string} value - string containing one or more words
         */
        this.gtSearch = function (value) {
            this.gtInfo.searchTerms = value;
            //always go to first page when searching
            this.goToPage(1);
        };
        /**
         * Create store to hold previously loaded records.
         * @param {number} records - total number of records in store.
         * @param {number} perPage - how many records to show per page.
         * @returns {Array} a nested array to hold records per page.
         */
        this.createStore = function (records, perPage) {
            var stores = Math.ceil(records / perPage);
            var store = [];
            for (var i = 0; i < stores; i++) {
                store[i] = [];
            }
            return store;
        };
        /**
         * Create placeholders for rows while loading data from back-end.
         * @param {number} perPage - how many records to show per page.
         * @returns {Array} an array containing empty records to be presented while fetching real data.
         */
        this.loadingContent = function (perPage) {
            // create row object
            var rowObject = {
                $$loading: true
            };
            var order = 0;
            // sort settings by column order
            this.gtSettings.sort(this.getColumnOrder);
            // loop through all settings objects...
            for (var i = 0; i < this.gtSettings.length; i++) {
                var setting = this.gtSettings[i];
                // ...if column is visible and enabled...
                if (setting.visible !== false && setting.enabled !== false) {
                    // ...if first column, set value to loading text otherwise leave it empty
                    if (order === 0) {
                        //console.log(setting.objectKey);
                        rowObject[setting.objectKey] = this.gtTexts.loading;
                        this.loadingProperty = setting.objectKey;
                    }
                    else {
                        rowObject[setting.objectKey] = '';
                    }
                    order++;
                }
                else {
                    rowObject[setting.objectKey] = '';
                }
            }
            // create content placeholder
            var contentPlaceholder = [];
            // create equal number of rows as rows per page
            for (var i = 0; i < perPage; i++) {
                // ...add temporary row object
                contentPlaceholder.push(rowObject);
            }
            return contentPlaceholder;
        };
        // TODO: move to helper functions
        /** Sort by sort order */
        this.getSortOrder = function (a, b) {
            if (a.sortOrder < b.sortOrder)
                return -1;
            if (a.sortOrder > b.sortOrder || typeof a.sortOrder === 'undefined')
                return 1;
            return 0;
        };
        // TODO: move to helper functions
        /** Sort by column order */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder === undefined) {
                return -1;
            }
            if (a.columnOrder < b.columnOrder)
                return -1;
            if (a.columnOrder > b.columnOrder)
                return 1;
            return 0;
        };
        /** Store filtered data for export */
        this.data = {
            exportData: []
        };
        /** Return property */
        this.getProperty = function (array, key) {
            for (var i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
        /**
         *  Extend object function.
         */
        this.extend = function (a, b) {
            for (var key in b)
                if (b.hasOwnProperty(key))
                    a[key] = b[key];
            return a;
        };
        this.gtEvent.subscribe(function ($event) {
            if ($event.name === 'gt-info') {
                _this.updateRecordRange();
            }
        });
    }
    /**
     * Get meta data for row.
     */
    GenericTableComponent.prototype.getRowState = function (row) {
        return typeof this.metaInfo[row.$$gtRowId] === 'undefined' ? null : this.metaInfo[row.$$gtRowId];
    };
    /**
     * Expand all rows.
     */
    GenericTableComponent.prototype.expandAllRows = function () {
        this._toggleAllRowProperty('isOpen', true);
    };
    /**
     * Collapse all rows.
     */
    GenericTableComponent.prototype.collapseAllRows = function () {
        this._toggleAllRowProperty('isOpen', false);
    };
    /**
     * Select all rows.
     */
    GenericTableComponent.prototype.selectAllRows = function () {
        this._toggleAllRowProperty('isSelected', true);
    };
    /**
     * Deselect all rows.
     */
    GenericTableComponent.prototype.deselectAllRows = function () {
        this._toggleAllRowProperty('isSelected', false);
    };
    /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param {GtRow} row - row object that should be expanded/collapsed.
     */
    GenericTableComponent.prototype.toggleCollapse = function (row) {
        this._toggleRowProperty(row, 'isOpen');
    };
    /**
     * Toggle row selected state ie. selected or not.
     * @param {GtRow} row - row object that should be selected/deselected.
     */
    GenericTableComponent.prototype.toggleSelect = function (row) {
        this._toggleRowProperty(row, 'isSelected');
    };
    /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param {Array} array - array that holds rows that need to be updated.
     * @param {string} property - name of property that should be changed/toggled.
     * @param {boolean} active - should rows be expanded/open, selected.
     */
    GenericTableComponent.prototype._updateMetaInfo = function (array, property, active) {
        for (var i = 0; i < array.length; i++) {
            if (!this.metaInfo[array[i].$$gtRowId]) {
                this.metaInfo[array[i].$$gtRowId] = {};
            }
            this.metaInfo[array[i].$$gtRowId][property] = active;
        }
    };
    /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param {Array} target - array to which rows should be added.
     * @param {Array} source - array that holds rows that should be added.
     * @returns {Array} array with added rows.
     */
    GenericTableComponent.prototype._pushLazyRows = function (target, source) {
        for (var i = 0; i < source.length; i++) {
            target.push(source[i]);
        }
        return target;
    };
    /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param {string} property - name of property that should be changed/toggled.
     * @param {boolean} active - should rows be expanded/open, selected.
     */
    GenericTableComponent.prototype._toggleAllRowProperty = function (property, active) {
        var eventName;
        var eventValue;
        switch (property) {
            case 'isOpen':
                if (active) {
                    eventName = 'expand-all';
                    this.openRows = this.gtOptions.lazyLoad ? this._pushLazyRows(this.openRows, this.gtData[this.gtInfo.pageCurrent - 1].slice()) : this.gtData.slice();
                    this._updateMetaInfo(this.openRows, property, active);
                }
                else {
                    eventName = 'collapse-all';
                    this._updateMetaInfo(this.openRows, property, active);
                    this.openRows = [];
                }
                eventValue = {
                    expandedRows: this.openRows,
                    changedRow: 'all'
                };
                //array = this.openRows;
                break;
            case 'isSelected':
                if (active) {
                    eventName = 'select-all';
                    this.selectedRows = this.gtOptions.lazyLoad ? this._pushLazyRows(this.selectedRows, this.gtData[this.gtInfo.pageCurrent - 1].slice()) : this.gtData.slice();
                    this._updateMetaInfo(this.selectedRows, property, active);
                }
                else {
                    eventName = 'deselect-all';
                    this._updateMetaInfo(this.selectedRows, property, active);
                    this.selectedRows = [];
                }
                eventValue = {
                    selectedRows: this.selectedRows,
                    changedRow: 'all'
                };
                break;
        }
        this.gtEvent.emit({
            name: 'gt-row-' + eventName,
            value: eventValue
        });
    };
    /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param {Object} row - row object.
     * @param {string} property - name of property that should be changed/toggled.
     */
    GenericTableComponent.prototype._toggleRowProperty = function (row, property) {
        var eventName;
        var eventValue;
        // make sure gtRowId exists on row object
        if (typeof row.$$gtRowId !== 'undefined') {
            // check if meta info exists for row
            if (!this.metaInfo[row.$$gtRowId]) {
                // if not, add object to store meta info
                this.metaInfo[row.$$gtRowId] = {};
            }
            switch (property) {
                case 'isOpen':
                    var opened = this.metaInfo[row.$$gtRowId][property];
                    // check if row is selected
                    if (!opened) {
                        eventName = 'expand';
                        // add row to selected rows
                        this.openRows.push(row);
                    }
                    else {
                        eventName = 'collapse';
                        // loop through selected rows...
                        for (var i = 0; i < this.openRows.length; i++) {
                            // if selected row equals passed row...
                            if (this.openRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from selected rows...
                                this.openRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        expandedRows: this.openRows,
                        changedRow: row
                    };
                    break;
                case 'isSelected':
                    var selected = this.metaInfo[row.$$gtRowId][property];
                    // check if row is selected
                    if (!selected) {
                        eventName = 'select';
                        // add row to selected rows
                        this.selectedRows.push(row);
                    }
                    else {
                        eventName = 'deselect';
                        // loop through selected rows...
                        for (var i = 0; i < this.selectedRows.length; i++) {
                            // if selected row equals passed row...
                            if (this.selectedRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from selected rows...
                                this.selectedRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        selectedRows: this.selectedRows,
                        changedRow: row
                    };
                    break;
            }
            this.gtEvent.emit({
                name: 'gt-row-' + eventName,
                value: eventValue
            });
            this.metaInfo[row.$$gtRowId][property] = !this.metaInfo[row.$$gtRowId][property];
        }
    };
    /** Export data as CSV
     * @param {string} fileName - optional file name (overrides default file name).
     */
    GenericTableComponent.prototype.exportCSV = function (fileName) {
        var _this = this;
        var data = this.data.exportData;
        var csv = '';
        //csv export headers
        for (var i = 0; i < this.gtSettings.length; i++) {
            if (this.gtSettings[i].export !== false) {
                csv += this.getProperty(this.gtFields, this.gtSettings[i].objectKey).name;
                if (i < (this.gtSettings.length - 1)) {
                    csv += this.gtOptions.csvDelimiter; //this.csvSeparator;
                }
            }
        }
        // csv export body
        data.forEach(function (row, i) {
            csv += '\n';
            for (var i_1 = 0; i_1 < _this.gtSettings.length; i_1++) {
                if (_this.gtSettings[i_1].export !== false) {
                    // get field settings
                    var fieldSetting = _this.getProperty(_this.gtFields, _this.gtSettings[i_1].objectKey);
                    // get export value, if export function is defined use it otherwise check for value function and as a last resort export raw data
                    csv += fieldSetting.export && typeof fieldSetting.export === 'function' ?
                        fieldSetting.export(row) : fieldSetting.value && typeof fieldSetting.value === 'function' ?
                        fieldSetting.value(row) : row[_this.gtSettings[i_1].objectKey];
                    if (i_1 < (_this.gtSettings.length - 1)) {
                        csv += _this.gtOptions.csvDelimiter; //this.csvSeparator;
                    }
                }
            }
        });
        var blob = new Blob([csv], {
            type: 'text/csv;charset=utf-8;'
        });
        if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, fileName ? fileName : this.gtTexts.csvDownload + '.csv');
        }
        else {
            var link = document.createElement("a");
            link.style.display = 'none';
            document.body.appendChild(link);
            if (link.download !== undefined) {
                link.setAttribute('href', URL.createObjectURL(blob));
                link.setAttribute('download', fileName ? fileName : this.gtTexts.csvDownload + '.csv');
                document.body.appendChild(link);
                link.click();
            }
            else {
                csv = 'data:text/csv;charset=utf-8,' + csv;
                window.open(encodeURI(csv));
            }
            document.body.removeChild(link);
        }
        // emit export event
        this.gtEvent.emit({
            name: 'gt-exported-csv',
            value: fileName ? fileName : this.gtTexts.csvDownload + '.csv'
        });
    };
    GenericTableComponent.prototype.ngOnInit = function () {
        /** If we're not lazy loading data and handling sorting server side, we want to apply some default sorting.
         *  This is done by checking sort properties in the settings array of the table, if no sorting is defined
         *  we'll sort the data by the first visible and enabled column in the table(ascending). */
        // if not using lazy loading...
        if (!this.gtOptions.lazyLoad) {
            // ...create sorting array
            var sorting = [];
            // ...sort settings by sort order
            this.gtSettings.sort(this.getSortOrder);
            // ...loop through settings
            for (var i = 0; i < this.gtSettings.length; i++) {
                var setting = this.gtSettings[i];
                // ...if sorted ascending...
                if (setting.sort === 'asc') {
                    // ... add to sorting
                    sorting.push(setting.objectKey);
                }
                else if (setting.sort === 'desc') {
                    // ... add to sorting
                    sorting.push("-" + setting.objectKey);
                }
            }
            // ...if no sorting applied...
            if (sorting.length === 0) {
                // ...sort settings by column order
                this.gtSettings.sort(this.getColumnOrder);
                // ...loop through settings
                for (var i = 0; i < this.gtSettings.length; i++) {
                    var setting = this.gtSettings[i];
                    // ...if column is enabled and visible...
                    if (setting.enabled !== false && setting.visible !== false) {
                        // ...add first match and exit function
                        this.sortOrder = [this.gtSettings[i].objectKey];
                        return;
                    }
                }
            }
            else {
                this.sortOrder = sorting;
            }
        }
    };
    GenericTableComponent.prototype.ngOnChanges = function (changes) {
        // if gt options have changed...
        if (changes['gtOptions']) {
            // ...extend gtOptions default values with values passed into component
            this.gtOptions = this.extend(this.gtDefaultOptions, this.gtOptions);
        }
        // if gt texts have changed...
        if (changes['gtTexts']) {
            // ...extend gtOptions default values with values passed into component
            this.gtTexts = this.extend(this.gtDefaultTexts, this.gtTexts);
        }
        // if lazy loading data and paging information is available...
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            // ...calculate total number of pages
            this.gtInfo.pageTotal = Math.ceil(this.gtInfo.recordsAfterSearch / this.gtInfo.recordLength);
            // ...declare store position
            var storePosition = this.gtInfo.pageCurrent - 1;
            // ...and if store is empty or page length has changed...
            if (this.store.length === 0 || this.store[0].length !== this.gtInfo.recordLength) {
                //console.log('create store');
                // ...create store
                this.store = this.createStore(this.gtInfo.recordsAfterSearch, this.gtInfo.recordLength);
            }
            // ...store retrieved data in store at store position
            this.store[storePosition] = this.gtData;
            // replace data with store
            this.gtData = this.store;
            this.loading = false;
            this.updateRecordRange();
        }
        else if (this.gtData.length > 0) {
            this.loading = false;
        }
    };
    return GenericTableComponent;
}());
GenericTableComponent.decorators = [
    { type: core_1.Component, args: [{
                selector: 'generic-table',
                template: "\n    <table class=\"table\" ngClass=\"{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}\" *ngIf=\"(gtFields | gtVisible:gtSettings:refreshPipe).length > 0\">\n      <thead>\n      <tr>\n        <th class=\"gt-sort-label\" *ngIf=\"gtOptions.stack\">{{gtTexts.sortLabel}}</th><th *ngFor=\"let column of gtFields | gtVisible:gtSettings:refreshPipe\" ngClass=\"{{column.objectKey +'-column' | dashCase}} {{column.classNames}} sort-{{gtSettings | gtProperty:column.objectKey:'sort':refreshHeading}} sort-order-{{gtSettings | gtProperty:column.objectKey:'sortOrder':refreshHeading}}\" (click)=\"gtSort(column.objectKey,$event);refreshHeading = !refreshHeading\">{{column.name}}</th>\n      </tr>\n      </thead>\n      <tbody *ngIf=\"gtData && gtInfo\">\n      <ng-template class=\"table-rows\" ngFor let-row [ngForOf]=\"gtOptions.lazyLoad && gtInfo ? (gtData[gtInfo.pageCurrent-1] | gtMeta:(gtInfo.pageCurrent-1):gtInfo.recordLength) : (gtData | gtMeta:null:null:gtData.length | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length | gtOrderBy:sortOrder:gtFields:refreshSorting:gtData.length | gtChunk:gtInfo:gtInfo.recordLength:gtInfo.pageCurrent:refreshPageArray:gtData.length:gtEvent:data)\">\n        <tr [ngClass]=\"{'row-selected':metaInfo[row.$$gtRowId]?.isSelected, 'row-open':metaInfo[row.$$gtRowId]?.isOpen, 'row-loading':loading}\" (click)=\"gtOptions.rowSelection ? toggleSelect(row):null\">\n          <td *ngFor=\"let column of row | gtRender:gtSettings:gtFields:refreshPipe:loading:gtOptions.highlightSearch:gtInfo.searchTerms;\" ngClass=\"{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}}\">\n            <span class=\"gt-row-label\" *ngIf=\"gtOptions.stack\">{{(gtFields | gtProperty:column.objectKey:'stackedHeading')? (gtFields | gtProperty:column.objectKey:'stackedHeading'):(gtFields | gtProperty:column.objectKey:'name')}}</span>\n            <gt-custom-component-factory *ngIf=\"column.columnComponent\" class=\"gt-row-content\" [type]=\"column.columnComponent.type\" [injector]=\"column.columnComponent.injector\" [row]=\"row\" [column]=\"column\" (redrawEvent)=\"redraw($event)\" (click)=\"column.click ? column.click(row,column):'';column.expand ? toggleCollapse(row):''\"></gt-custom-component-factory>\n            <span *ngIf=\"!column.columnComponent\" class=\"gt-row-content\" [innerHTML]=\"column.renderValue\" (click)=\"column.click ? column.click(row,column):'';column.expand ? toggleCollapse(row):''\"></span>\n          </td>\n        </tr>\n        <tr class=\"row-expanded\" *ngIf=\"metaInfo[row.$$gtRowId]?.isOpen\">\n          <td [attr.colspan]=\"(gtFields | gtVisible:gtSettings:refreshPipe).length\">\n            <gt-expanding-row [row]=\"row\" [type]=\"gtRowComponent\" (redrawEvent)=\"redraw($event)\" (toggleRowEvent)=\"toggleCollapse($event)\"></gt-expanding-row>\n          </td>\n        </tr>\n      </ng-template>\n      <tr *ngIf=\"gtInfo.pageTotal === 0 && (gtInfo.searchTerms || gtInfo.filter) && !loading\">\n        <td class=\"gt-no-matching-results\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">{{gtTexts.noMatchingData}}</td>\n      </tr>\n      <tr *ngIf=\"gtInfo.pageTotal === 0 && !(gtInfo.searchTerms || gtInfo.filter) && !loading\">\n        <td class=\"gt-no-results\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">{{gtTexts.noData}}</td>\n      </tr>\n      <tr *ngIf=\"gtInfo.pageTotal === 0 && loading\">\n        <td class=\"gt-loading-data\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">{{gtTexts.loading}}</td>\n      </tr>\n      </tbody>\n    </table>\n    <table class=\"table\" *ngIf=\"(gtFields | gtVisible:gtSettings:refreshPipe).length === 0\">\n      <thead>\n      <tr>\n        <th class=\"gt-no-visible-columns\">{{gtTexts.noVisibleColumnsHeading}}</th>\n      </tr>\n      </thead>\n      <tbody>\n      <tr>\n        <td class=\"gt-no-visible-columns\">{{gtTexts.noVisibleColumns}}</td>\n      </tr>\n      </tbody>\n    </table>\n  ",
            },] },
];
/** @nocollapse */
GenericTableComponent.ctorParameters = function () { return []; };
GenericTableComponent.propDecorators = {
    'gtRowComponent': [{ type: core_1.Input },],
    'gtSettings': [{ type: core_1.Input },],
    'gtFields': [{ type: core_1.Input },],
    'gtData': [{ type: core_1.Input },],
    'gtTexts': [{ type: core_1.Input },],
    'gtClasses': [{ type: core_1.Input },],
    'gtEvent': [{ type: core_1.Output },],
    'gtOptions': [{ type: core_1.Input },],
    'gtInfo': [{ type: core_1.Input },],
};
exports.GenericTableComponent = GenericTableComponent;
//# sourceMappingURL=generic-table.component.js.map