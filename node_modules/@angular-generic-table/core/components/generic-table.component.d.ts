import { OnInit, OnChanges, EventEmitter, Type, SimpleChanges, Renderer2, OnDestroy } from '@angular/core';
import { GtConfig, GtConfigField, GtConfigSetting, GtTexts, GtInformation, GtExpandedRow, GtRow, GtOptions, GtRowMeta, GtRenderField, GtEvent } from '..';
import { GtMetaPipe } from '../pipes/gt-meta.pipe';
export declare class GenericTableComponent<R extends GtRow, C extends GtExpandedRow<R>> implements OnInit, OnChanges, OnDestroy {
    private renderer;
    private gtMetaPipe;
    gtRowComponent: Type<C>;
    readonly hasEdits: boolean;
    gtOptions: GtOptions;
    gtTotals: any;
    gtFields: GtConfigField<R, any>[];
    gtSettings: GtConfigSetting[];
    gtData: Array<any>;
    columnWidth: Object;
    configObject: GtConfig<R>;
    sortOrder: Array<any>;
    metaInfo: {
        [gtRowId: string]: GtRowMeta;
    };
    selectedRows: Array<GtRow>;
    openRows: Array<GtRow>;
    private _gtSettings;
    private _gtFields;
    private _gtData;
    private _gtTotals;
    private _gtRowComponent;
    expandedRow: {
        component: Type<C>;
        data?: Array<any>;
    };
    gtDefaultTexts: GtTexts;
    gtTexts: GtTexts;
    gtClasses: string;
    gtEvent: EventEmitter<GtEvent>;
    gtDefaultOptions: GtOptions;
    private _gtOptions;
    store: Array<any>;
    loading: boolean;
    private debounceTimer;
    loadingProperty: string;
    lazyAllSelected: boolean;
    gtInfo: GtInformation;
    refreshPipe: boolean;
    refreshTotals: boolean;
    refreshSorting: boolean;
    refreshFilter: boolean;
    refreshPageArray: boolean;
    private globalInlineEditListener;
    editedRows: {
        [key: string]: {
            changes: {
                [key: string]: GtRenderField<GtRow, any>;
            };
            row: GtRow;
        };
    };
    data: {
        exportData: Array<any>;
    };
    constructor(renderer: Renderer2, gtMetaPipe: GtMetaPipe);
    /**
     * Sort table by object key.
     * @param objectKey - name of key to sort on.
     * @param event - such as key press during sorting.
     */
    gtSort: (objectKey: string, event: any) => void;
    /**
     * Change number of rows to be displayed.
     * @param rowLength - total number of rows.
     * @param reset - should page be reset to first page.
     */
    changeRowLength: (rowLength: any, reset?: boolean) => void;
    /**
     * Force a redraw of table rows.
     * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
     */
    redraw: ($event?: any) => void;
    /** Update record range. */
    private updateRecordRange();
    /** Update totals. */
    private updateTotals();
    /** Go to next page. */
    nextPage: () => void;
    /** Go to previous page. */
    previousPage: () => void;
    /** Request more data (used when lazy loading) */
    private getData;
    /**
     * Go to specific page.
     * @param page - page number.
     */
    goToPage: (page: number) => void;
    /**
     * Get meta data for row.
     */
    getRowState(row: R): GtRowMeta;
    /**
     * Expand all rows.
     * @param expandedRow - component to render when rows are expanded.
     */
    expandAllRows(expandedRow: {
        component: Type<C>;
        data?: any;
    }): void;
    /**
     * Collapse all rows.
     */
    collapseAllRows(): void;
    /**
     * Select all rows.
     */
    selectAllRows(): void;
    /**
     * Deselect all rows.
     */
    deselectAllRows(): void;
    /**
     * Toggle all rows.
     */
    toggleAllRows(): void;
    /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param row - row object that should be expanded/collapsed.
     * @param expandedRow - component to render when row is expanded.
     */
    toggleCollapse(row: GtRow, expandedRow?: {
        component: Type<C>;
        data?: any;
    }): void;
    /**
     * Toggle row selected state ie. selected or not.
     * @param row - row object that should be selected/deselected.
     */
    toggleSelect(row: GtRow): void;
    rowClick(row: GtRow, $event: MouseEvent): void;
    /**
     * Update row data.
     * @param row - row object that has been edited.
     * @param oldValue - row object before edit.
     */
    updateRow(row: GtRow, oldValue: GtRow): void;
    /**
     * removes a row from the table
     * @param row - the row object to remove
     */
    removeRow(row: GtRow): void;
    /**
     * check if a row is selected
     * @param row - row object
     */
    isRowSelected(row: GtRow): boolean;
    /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param array - array that holds rows that need to be updated.
     * @param property - name of property that should be changed/toggled.
     * @param active - should rows be expanded/open, selected.
     * @param exception - update all rows except this one.
     */
    private _updateMetaInfo(array, property, active, exception?);
    /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param target - array to which rows should be added.
     * @param source - array that holds rows that should be added.
     * @returns array with added rows.
     */
    private _pushLazyRows(target, source);
    /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param property - name of property that should be changed/toggled.
     * @param active - should rows be expanded/open, selected.
     */
    private _toggleAllRowProperty(property, active);
    /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param row - row object.
     * @param property - name of property that should be changed/toggled.
     * @param propertyValues - optional property values that can be passed.
     */
    private _toggleRowProperty(row, property, propertyValues?);
    /**
     * Update column.
     * @param $event - key up event.
     * @param row - row object.
     * @param column - column object.
     */
    gtUpdateColumn($event: KeyboardEvent, row: GtRow, column: GtRenderField<any, any>): void;
    /**
     * Dropdown select.
     * @param row - row object.
     * @param column - column object.
     */
    gtDropdownSelect(row: GtRow, column: GtRenderField<any, any>): void;
    private _editRow(row, column);
    /**
     * Listen for key down event - listen for key down event during inline edit.
     */
    private _listenForKeydownEvent();
    /**
     * Inline edit update - accept changes and update row values.
     */
    inlineEditUpdate(): void;
    /**
     * Inline edit cancel - cancel and reset inline edits.
     */
    inlineEditCancel(row?: GtRow): void;
    /**
     * Stop listening for key down event - stop listening for key down events passed during inline edit.
     */
    private _stopListeningForKeydownEvent();
    /**
     * Apply filter(s).
     * @param filter - object containing key value pairs, where value should be array of values.
     */
    gtApplyFilter(filter: Object): void;
    /** Clear/remove applied filter(s). */
    gtClearFilter(): void;
    /**
     * Search
     * @param value - string containing one or more words
     */
    gtSearch(value: string): void;
    /**
     * Add rows
     * @param rows - rows to add
     * @returns new data array.
     */
    gtAdd(rows: Array<R>): ReadonlyArray<R>;
    /**
     * Delete row
     * @param objectKey - object key you want to find match with
     * @param value - the value that should be deleted
     * @param match - all: delete all matches, first: delete first match (default)
     * @returns new data array.
     */
    gtDelete(objectKey: string, value: string | number, match?: 'first' | 'all'): ReadonlyArray<R>;
    /**
     * Create store to hold previously loaded records.
     * @param records - total number of records in store.
     * @param perPage - how many records to show per page.
     * @returns a nested array to hold records per page.
     */
    private createStore(records, perPage);
    /**
     * Create placeholders for rows while loading data from back-end.
     * @param perPage - how many records to show per page.
     * @returns an array containing empty records to be presented while fetching real data.
     */
    private loadingContent(perPage);
    /** Sort by sort order */
    private getSortOrder;
    /** Sort by column order */
    private getColumnOrder;
    /** Create a deep copy of data */
    private cloneDeep;
    /** Export data as CSV
     * @param fileName - optional file name (overrides default file name).
     * @param useBOM - use BOM (byte order marker).
     */
    exportCSV(fileName?: string, useBOM?: boolean): void;
    /** Return property */
    private getProperty;
    private restructureSorting;
    ngOnInit(): void;
    /**
     *  Extend object function.
     */
    private extend;
    ngOnChanges(changes: SimpleChanges): void;
    trackByFn(index: number, item: GtRow): any;
    trackByColumnFn(index: number, item: GtConfigField<any, any>): string;
    ngOnDestroy(): void;
}
