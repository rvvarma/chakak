/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, Output, Input, EventEmitter, Type, Renderer2 } from '@angular/core';
import { GtMetaPipe } from '../pipes/gt-meta.pipe';
// unsupported: template constraints.
// unsupported: template constraints.
/**
 * @template R, C
 */
export class GenericTableComponent {
    /**
     * @param {?} renderer
     * @param {?} gtMetaPipe
     */
    constructor(renderer, gtMetaPipe) {
        this.renderer = renderer;
        this.gtMetaPipe = gtMetaPipe;
        this.columnWidth = {};
        this.sortOrder = [];
        this.metaInfo = {};
        this.selectedRows = [];
        this.openRows = [];
        this._gtSettings = [];
        this._gtFields = [];
        this.gtDefaultTexts = {
            loading: 'Loading...',
            noData: 'No data',
            noMatchingData: 'No data matching results found',
            noVisibleColumnsHeading: 'No visible columns',
            noVisibleColumns: 'Please select at least one column to be visible.',
            tableInfo: 'Showing #recordFrom to #recordTo of #recordsAfterSearch entries.',
            tableInfoAfterSearch: 'Showing  #recordFrom to #recordTo of #recordsAfterSearch entries (filtered from a total of #recordsAll entries).',
            csvDownload: 'download',
            sortLabel: 'Sort:',
            paginateNext: 'Next page',
            paginatePrevious: 'Previous page',
            inlineEditEdited: 'Press enter to save'
        };
        this.gtTexts = this.gtDefaultTexts;
        this.gtEvent = new EventEmitter();
        this.gtDefaultOptions = {
            csvDelimiter: ';',
            stack: false,
            lazyLoad: false,
            cache: false,
            debounceTime: 200,
            highlightSearch: false,
            rowSelection: false,
            rowSelectionAllowMultiple: true,
            rowExpandAllowMultiple: true,
            numberOfRows: 10,
            reportColumnWidth: false,
            allowUnsorted: true,
            mutateData: true
        };
        this._gtOptions = this.gtDefaultOptions;
        this.store = [];
        this.loading = true;
        this.debounceTimer = null;
        this.lazyAllSelected = false;
        this.gtInfo = {
            pageCurrent: 1,
            pageTotal: 0,
            recordFrom: 0,
            recordTo: 0,
            recordLength: this.gtOptions.numberOfRows,
            recordsAll: 0,
            recordsAfterFilter: 0,
            recordsAfterSearch: 0
        };
        this.refreshPipe = false;
        this.refreshTotals = false;
        this.refreshSorting = false;
        this.refreshFilter = false;
        this.refreshPageArray = false;
        this.editedRows = {};
        this.data = { exportData: [] };
        /**
         * Sort table by object key.
         * @param objectKey - name of key to sort on.
         * @param event - such as key press during sorting.
         */
        this.gtSort = function (objectKey, event) {
            this.inlineEditCancel(); // cancel inline editing
            // loop through current settings
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    // check if sorting is disabled...
                    if (this._gtSettings[i].sort &&
                        this._gtSettings[i].sort.indexOf('disable') !== -1) {
                        // ...if so, exit function without applying any sorting
                        return;
                    }
                    else if (/* check if sorting is undefined... */ typeof this._gtSettings[i]
                        .sort === 'undefined') {
                        // ...is so, set sorting property to enable
                        this._gtSettings[i].sort = 'enable';
                    }
                }
            }
            // check length
            const /** @type {?} */ ctrlKey = event.metaKey || event.ctrlKey;
            const /** @type {?} */ sort = this.sortOrder.slice(0);
            let /** @type {?} */ match = -1;
            let /** @type {?} */ matchDesc = -1;
            let /** @type {?} */ pos = -1;
            // check if property already exits
            for (let /** @type {?} */ i = 0; i < sort.length; i++) {
                const /** @type {?} */ hit = sort[i].indexOf(objectKey);
                if (hit !== -1) {
                    match = this.sortOrder.indexOf(objectKey);
                    matchDesc =
                        match === -1 ? this.sortOrder.indexOf('-' + objectKey) : match;
                    pos = Math.max(match, matchDesc);
                }
            }
            // if ctrl key or meta key is press together with sort...
            if (ctrlKey) {
                if (this.sortOrder[this.sortOrder.length - 1] === '$$gtInitialRowIndex') {
                    this.sortOrder.pop();
                }
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...add property to sorting
                        this.sortOrder.push(objectKey);
                        break;
                    default:
                        // ...and property is sorted before...
                        if (match !== -1) {
                            // ...change from asc to desc if sorted asc
                            this.sortOrder[pos] = '-' + objectKey;
                        }
                        else if (this.sortOrder.length > 1) {
                            // ...remove sorting if sorted desc
                            if (ctrlKey) {
                                this.sortOrder[pos] = objectKey;
                            }
                            else {
                                this.sortOrder.splice(pos, 1);
                            }
                        }
                        else if (this.sortOrder.length === 1) {
                            // ...set sorting to asc if only sorted property
                            this.sortOrder[pos] = objectKey;
                        }
                        break;
                }
            }
            else {
                /* if ctrl key or meta key is not press together with sort... */
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...sort by property
                        this.sortOrder = [objectKey];
                        break;
                    default:
                        // ...change from desc to asc and vise versa
                        this.sortOrder =
                            match !== -1
                                ? ['-' + objectKey]
                                : ctrlKey || !this.gtOptions.allowUnsorted
                                    ? [objectKey]
                                    : [];
                        break;
                }
            }
            // update settings object with new sorting information
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    switch (this._gtSettings[i].sort) {
                        // if sorted asc...
                        case 'asc':
                            // ...change to desc
                            this._gtSettings[i].sort = 'desc';
                            break;
                        // if sorted desc...
                        case 'desc':
                            // ...change to asc if it's the only sorted property otherwise remove sorting
                            this._gtSettings[i].sort =
                                (this.sortOrder.length === 1 && sort.length < 2) ||
                                    ctrlKey ||
                                    !this.gtOptions.allowUnsorted
                                    ? 'asc'
                                    : 'enable';
                            break;
                        // if sorting enabled...
                        case 'enable':
                            // ...change to asc
                            this._gtSettings[i].sort = 'asc';
                            break;
                    }
                    this._gtSettings[i].sortOrder =
                        this._gtSettings[i].sort === 'enable'
                            ? this._gtSettings.length - 1
                            : this.sortOrder.indexOf(objectKey) === -1
                                ? this.sortOrder.indexOf('-' + objectKey)
                                : this.sortOrder.indexOf(objectKey);
                }
                else if (this._gtSettings[i].sort &&
                    this._gtSettings[i].sort.indexOf('disable') === -1 &&
                    this.sortOrder.indexOf(this._gtSettings[i].objectKey) === -1 &&
                    this.sortOrder.indexOf('-' + this._gtSettings[i].objectKey) === -1) {
                    this._gtSettings[i].sort = 'enable';
                    this._gtSettings[i].sortOrder = this._gtSettings.length - 1;
                }
            }
            // refresh sorting pipe
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            // sort by initial sort order as last resort
            this.sortOrder.push('$$gtInitialRowIndex');
            // emit sort event
            this.gtEvent.emit({
                name: 'gt-sorting-applied',
                value: this.sortOrder
            });
        };
        /**
         * Change number of rows to be displayed.
         * @param rowLength - total number of rows.
         * @param reset - should page be reset to first page.
         */
        this.changeRowLength = function (rowLength, reset) {
            let /** @type {?} */ lengthValue = isNaN(parseInt(rowLength, 10))
                ? 0
                : parseInt(rowLength, 10);
            let /** @type {?} */ newPosition = 1;
            if (!lengthValue && this.gtData) {
                lengthValue = this.gtData.length;
            }
            // if reset is not true and we're not lazy loading data...
            if (reset !== true && this._gtOptions.lazyLoad !== true) {
                // ...get current position in record set
                const /** @type {?} */ currentRecord = this.gtInfo.recordLength * (this.gtInfo.pageCurrent - 1);
                const /** @type {?} */ currentPosition = this._gtData.indexOf(this._gtData[currentRecord]) + 1;
                // ...get new position
                newPosition = Math.ceil(currentPosition / lengthValue);
            }
            // change row length
            this.gtInfo.recordLength = lengthValue;
            // go to new position
            this.gtInfo.pageCurrent = newPosition;
            // if lazy loading data...
            if (this._gtOptions.lazyLoad) {
                // ...replace data with place holders for new data
                this._gtData[0] = this.loadingContent(lengthValue);
                // ...empty current store
                this.store = [];
            }
            // this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-row-length-changed',
                value: lengthValue
            });
        };
        /**
         * Force a redraw of table rows.
         * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
         */
        this.redraw = function ($event) {
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            this.refreshPipe = !this.refreshPipe;
        };
        /**
         * Go to next page.
         */
        this.nextPage = function () {
            const /** @type {?} */ page = this.gtInfo.pageCurrent === this.gtInfo.pageTotal
                ? this.gtInfo.pageTotal
                : this.gtInfo.pageCurrent + 1;
            this.goToPage(page);
        };
        /**
         * Go to previous page.
         */
        this.previousPage = function () {
            const /** @type {?} */ page = this.gtInfo.pageCurrent === 1 ? 1 : this.gtInfo.pageCurrent - 1;
            this.goToPage(page);
        };
        /**
         * Request more data (used when lazy loading)
         */
        this.getData = function () {
            // ...emit event requesting for more data
            this.gtEvent.emit({
                name: 'gt-page-changed-lazy',
                value: {
                    pageCurrent: this.gtInfo.pageCurrent,
                    recordLength: this.gtInfo.recordLength
                }
            });
        };
        /**
         * Go to specific page.
         * @param page - page number.
         */
        this.goToPage = function (page) {
            const /** @type {?} */ previousPage = this.gtInfo.pageCurrent;
            this.gtInfo.pageCurrent = page;
            this.inlineEditCancel(); // cancel inline edit
            // if lazy loading and if page contains no records...
            if (this._gtOptions.lazyLoad) {
                // ...if data for current page contains no entries...
                if (this._gtOptions.cache === false ||
                    this._gtData[this.gtInfo.pageCurrent - 1].length === 0) {
                    // ...create temporary content while waiting for data
                    this._gtData[this.gtInfo.pageCurrent - 1] = this.loadingContent(this.gtInfo.recordLength);
                    this.loading = true; // loading true
                }
                // ...if first entry in current page equals our loading placeholder...
                if (this._gtData[this.gtInfo.pageCurrent - 1][0][this.loadingProperty] ===
                    this.gtTexts.loading) {
                    // ...get data
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(() => {
                        this.getData();
                    }, this._gtOptions.debounceTime);
                }
            }
            // this.updateRecordRange();
            // ...emit page change event
            if (previousPage !== page) {
                this.gtEvent.emit({
                    name: 'gt-page-changed',
                    value: {
                        pageCurrent: this.gtInfo.pageCurrent,
                        pagePrevious: previousPage,
                        recordLength: this.gtInfo.recordLength
                    }
                });
            }
        };
        /**
         * Sort by sort order
         */
        this.getSortOrder = function (a, b) {
            if (a.sortOrder < b.sortOrder) {
                return -1;
            }
            if (a.sortOrder > b.sortOrder || typeof a.sortOrder === 'undefined') {
                return 1;
            }
            return 0;
        };
        /**
         * Sort by column order
         */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder === undefined) {
                return -1;
            }
            if (a.columnOrder < b.columnOrder) {
                return -1;
            }
            if (a.columnOrder > b.columnOrder) {
                return 1;
            }
            return 0;
        };
        /**
         * Create a deep copy of data
         */
        this.cloneDeep = function (o) {
            return JSON.parse(JSON.stringify(o));
        };
        /**
         * Return property
         */
        this.getProperty = function (array, key) {
            for (let /** @type {?} */ i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
        this.restructureSorting = function () {
            /**
             * Check and store sort order upon initialization.
             *  This is done by checking sort properties in the settings array of the table, if no sorting is defined
             *  we'll sort the data by the first visible and enabled column in the table(ascending). Please note that actually
             *  sorting have to be done server side when lazy loading data for obvious reasons.
             */
            const /** @type {?} */ sorting = [];
            if (this._gtSettings) {
                // ...sort settings by sort order
                this._gtSettings.sort(this.getSortOrder);
                // ...loop through settings
                for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                    const /** @type {?} */ setting = this._gtSettings[i];
                    // ...if sorted ascending...
                    if (setting.sort === 'asc') {
                        // ... add to sorting
                        sorting.push(setting.objectKey);
                    }
                    else if (setting.sort === 'desc') {
                        /* ...else if sorted descending... */ 
                        // ... add to sorting
                        sorting.push('-' + setting.objectKey);
                    }
                }
                // ...if no sorting applied...
                if (sorting.length === 0) {
                    sorting.push('$$gtRowId');
                    /*// ...sort settings by column order
                                    this._gtSettings.sort(this.getColumnOrder);
                    
                                    // ...loop through settings
                                    for (let i = 0; i < this._gtSettings.length; i++) {
                                        const setting = this._gtSettings[i];
                    
                                        // ...if column is enabled and visible...
                                        if (setting.enabled !== false && setting.visible !== false) {
                                            // ...add first match and exit function
                                            this.sortOrder = [this._gtSettings[i].objectKey];
                                            return;
                                        }
                                    }*/
                }
            }
            if (this.sortOrder.length === 0) {
                this.sortOrder = sorting;
            }
        };
        /**
         *  Extend object function.
         */
        this.extend = function (a, b) {
            for (const /** @type {?} */ key in b) {
                if (b.hasOwnProperty(key)) {
                    a[key] = b[key];
                }
            }
            return a;
        };
        this.gtEvent.subscribe(($event) => {
            if ($event.name === 'gt-info') {
                this.updateRecordRange();
            }
            if ($event.name === 'gt-row-updated') {
                this.updateTotals();
            }
        });
    }
    /**
     * @return {?}
     */
    get gtRowComponent() {
        return this._gtRowComponent;
    }
    /**
     * @return {?}
     */
    get hasEdits() {
        return Object.keys(this.editedRows).length > 0;
    }
    /**
     * @return {?}
     */
    get gtOptions() {
        return this._gtOptions;
    }
    /**
     * @return {?}
     */
    get gtTotals() {
        return this._gtTotals;
    }
    /**
     * @return {?}
     */
    get gtFields() {
        return this._gtFields;
    }
    /**
     * @return {?}
     */
    get gtSettings() {
        return this._gtSettings;
    }
    /**
     * @return {?}
     */
    get gtData() {
        return this._gtData;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtOptions(value) {
        this._gtOptions = value;
        // if number of rows is passed and if number of rows differs from current record length...
        if (this.gtOptions.numberOfRows &&
            this.gtInfo.recordLength !== this.gtOptions.numberOfRows) {
            // ...update record length and redraw table
            this.gtInfo.recordLength = this.gtOptions.numberOfRows;
            this.redraw();
        }
        // ...extend gtOptions default values with values passed into component
        this._gtOptions = /** @type {?} */ (this.extend(this.gtDefaultOptions, this._gtOptions));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtTotals(value) {
        this._gtTotals = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtFields(value) {
        this._gtFields = value;
        const /** @type {?} */ COLUMNS_WITH_CLASS_NAMES = this._gtFields
            .map(column => column)
            .filter(column => column.classNames);
        // TODO: remove deprecated warning when setting has been removed
        if (COLUMNS_WITH_CLASS_NAMES.length > 0) {
            console.warn('Field setting "classNames" have been deprecated in favor for "columnClass" and will be removed in the future, please update field settings for column with object key: ' +
                COLUMNS_WITH_CLASS_NAMES[0].objectKey);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtSettings(value) {
        this._gtSettings = value;
        // loop through current settings
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            // set sort enabled/disabled setting
            this._gtSettings[i].sortEnabled =
                this._gtSettings[i].sortEnabled !== false
                    ? (this._gtSettings[i].sortEnabled = !(this._gtSettings[i].sort &&
                        this._gtSettings[i].sort.indexOf('disable') !== -1))
                    : false;
            // check if sorting is undefined...
            if (typeof this._gtSettings[i].sort === 'undefined') {
                // ...is so, set sorting property to enable
                this._gtSettings[i].sort = 'enable';
            }
            // check if column order is undefined...
            if (typeof this._gtSettings[i].columnOrder === 'undefined' &&
                this._gtSettings[i].enabled !== false) {
                // ...is so, set sorting property to enable
                this._gtSettings[i].columnOrder = this._gtSettings[i - 1]
                    ? this._gtSettings[i - 1].columnOrder + 1
                    : 0;
            }
            // check if column lock settings are undefined...
            if (typeof this._gtSettings[i].lockSettings === 'undefined') {
                // ...if so, set lock settings to false unless field is disabled (enable === false)
                this._gtSettings[i].lockSettings =
                    this._gtSettings[i].enabled === false || false;
            }
        }
        this.restructureSorting();
    }
    /**
     * @param {?} initialData
     * @return {?}
     */
    set gtData(initialData) {
        const /** @type {?} */ data = this._gtOptions.mutateData
            ? [...initialData]
            : this.cloneDeep(initialData);
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            this.gtMetaPipe.transform(data, this.gtOptions.rowIndex, this.gtInfo.pageCurrent - 1, this.gtInfo.recordLength);
            if (this.lazyAllSelected) {
                const /** @type {?} */ UNIQUE_ROWS = this.selectedRows.map(row => row.$$gtRowId);
                data.map(row => {
                    if (UNIQUE_ROWS.indexOf(row.$$gtRowId) === -1) {
                        this.selectedRows.push(row);
                    }
                });
                this._updateMetaInfo(this.selectedRows, 'isSelected', true);
            }
        }
        else {
            this.gtMetaPipe.transform(data, this.gtOptions.rowIndex);
        }
        if (this.gtOptions.rowSelectionInitialState) {
            data.map(row => {
                const /** @type {?} */ selected = typeof this.gtOptions.rowSelectionInitialState === 'function'
                    ? this.gtOptions.rowSelectionInitialState(row)
                    : this.gtOptions.rowSelectionInitialState;
                if (selected) {
                    if (typeof this.metaInfo[row.$$gtRowId] === 'undefined') {
                        this.metaInfo[row.$$gtRowId] = { isSelected: true };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId].isSelected = true;
                    }
                    this.selectedRows.push(row);
                }
            });
        }
        if (this.gtOptions.rowExpandInitialState &&
            this.gtOptions.rowExpandInitialComponent) {
            data.map(row => {
                const /** @type {?} */ expanded = typeof this.gtOptions.rowExpandInitialState === 'function'
                    ? this.gtOptions.rowExpandInitialState(row)
                    : this.gtOptions.rowExpandInitialState;
                this.expandedRow = this.gtOptions.rowExpandInitialComponent;
                if (expanded) {
                    if (typeof this.metaInfo[row.$$gtRowId] === 'undefined') {
                        this.metaInfo[row.$$gtRowId] = { isOpen: true };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId].isOpen = true;
                    }
                }
            });
        }
        this._gtData = data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtRowComponent(value) {
        console.warn('GtRowComponent has been deprecated and support will be removed in a future release, see https://github.com/hjalmers/angular-generic-table/issues/34');
        this._gtRowComponent = value;
    }
    /**
     * Update record range.
     * @return {?}
     */
    updateRecordRange() {
        this.gtInfo.recordFrom =
            this.gtInfo.recordsAfterSearch === 0
                ? 0
                : (this.gtInfo.pageCurrent - 1) * this.gtInfo.recordLength + 1;
        this.gtInfo.recordTo =
            this.gtInfo.recordsAfterSearch <
                this.gtInfo.pageCurrent * this.gtInfo.recordLength
                ? this.gtInfo.recordsAfterSearch
                : this.gtInfo.pageCurrent * this.gtInfo.recordLength;
    }
    /**
     * Update totals.
     * @return {?}
     */
    updateTotals() {
        this.refreshTotals = !this.refreshTotals;
    }
    /**
     * Get meta data for row.
     * @param {?} row
     * @return {?}
     */
    getRowState(row) {
        return typeof this.metaInfo[row.$$gtRowId] === 'undefined'
            ? null
            : this.metaInfo[row.$$gtRowId];
    }
    /**
     * Expand all rows.
     * @param {?} expandedRow - component to render when rows are expanded.
     * @return {?}
     */
    expandAllRows(expandedRow) {
        this.expandedRow = expandedRow;
        this._toggleAllRowProperty('isOpen', true);
    }
    /**
     * Collapse all rows.
     * @return {?}
     */
    collapseAllRows() {
        this._toggleAllRowProperty('isOpen', false);
    }
    /**
     * Select all rows.
     * @return {?}
     */
    selectAllRows() {
        this._toggleAllRowProperty('isSelected', true);
    }
    /**
     * Deselect all rows.
     * @return {?}
     */
    deselectAllRows() {
        this._toggleAllRowProperty('isSelected', false);
    }
    /**
     * Toggle all rows.
     * @return {?}
     */
    toggleAllRows() {
        if (this._gtOptions.lazyLoad) {
            if (!this.lazyAllSelected || this.selectedRows.length === 0) {
                this.selectAllRows();
                this.lazyAllSelected = true;
            }
            else {
                this.deselectAllRows();
                this.lazyAllSelected = false;
            }
        }
        else {
            if (this.selectedRows.length !== this.gtData.length) {
                this.selectAllRows();
            }
            else {
                this.deselectAllRows();
            }
        }
    }
    /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param {?} row - row object that should be expanded/collapsed.
     * @param {?=} expandedRow - component to render when row is expanded.
     * @return {?}
     */
    toggleCollapse(row, expandedRow) {
        if (expandedRow) {
            this.expandedRow = expandedRow;
        }
        this._toggleRowProperty(row, 'isOpen');
    }
    /**
     * Toggle row selected state ie. selected or not.
     * @param {?} row - row object that should be selected/deselected.
     * @return {?}
     */
    toggleSelect(row) {
        this._toggleRowProperty(row, 'isSelected');
    }
    /**
     * @param {?} row
     * @param {?} $event
     * @return {?}
     */
    rowClick(row, $event) {
        this.gtEvent.emit({
            name: 'gt-row-clicked',
            value: { row: row, event: $event }
        });
    }
    /**
     * Update row data.
     * @param {?} row - row object that has been edited.
     * @param {?} oldValue - row object before edit.
     * @return {?}
     */
    updateRow(row, oldValue) {
        this._toggleRowProperty(row, 'isUpdated', oldValue);
    }
    /**
     * removes a row from the table
     * @param {?} row - the row object to remove
     * @return {?}
     */
    removeRow(row) {
        if (this.isRowSelected(row)) {
            this.toggleSelect(row);
        }
        const /** @type {?} */ index = this._gtData.indexOf(row);
        this._gtData.splice(index, 1);
    }
    /**
     * check if a row is selected
     * @param {?} row - row object
     * @return {?}
     */
    isRowSelected(row) {
        return (this.metaInfo[row.$$gtRowId] && this.metaInfo[row.$$gtRowId].isSelected);
    }
    /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param {?} array - array that holds rows that need to be updated.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @param {?=} exception - update all rows except this one.
     * @return {?}
     */
    _updateMetaInfo(array, property, active, exception) {
        for (let /** @type {?} */ i = 0; i < array.length; i++) {
            if (!this.metaInfo[array[i].$$gtRowId]) {
                this.metaInfo[array[i].$$gtRowId] = {};
            }
            if (exception && array[i].$$gtRowId === exception.$$gtRowId) {
            }
            else {
                this.metaInfo[array[i].$$gtRowId][property] = active;
            }
        }
    }
    /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param {?} target - array to which rows should be added.
     * @param {?} source - array that holds rows that should be added.
     * @return {?} array with added rows.
     */
    _pushLazyRows(target, source) {
        const /** @type {?} */ UNIQUE_ROWS = target.map(row => row.$$gtRowId);
        for (let /** @type {?} */ i = 0; i < source.length; i++) {
            // only add if not already in list
            if (UNIQUE_ROWS.indexOf(source[i].$$gtRowId) === -1) {
                target.push(source[i]);
            }
        }
        return target;
    }
    /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @return {?}
     */
    _toggleAllRowProperty(property, active) {
        let /** @type {?} */ eventName;
        let /** @type {?} */ eventValue;
        switch (property) {
            case 'isOpen':
                // check if multiple expanded rows are allowed...
                if (this._gtOptions.rowExpandAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowExpandAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'expand-all';
                    this.openRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.openRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.openRows, property, active);
                }
                else {
                    eventName = 'collapse-all';
                    this._updateMetaInfo(this.openRows, property, active);
                    this.openRows = [];
                }
                eventValue = {
                    expandedRows: this.openRows,
                    changedRow: 'all'
                };
                break;
            case 'isSelected':
                // check if multi row selection is allowed...
                if (this._gtOptions.rowSelectionAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowSelectionAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'select-all';
                    this.selectedRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.selectedRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.selectedRows, property, active);
                }
                else {
                    eventName = 'deselect-all';
                    this._updateMetaInfo(this.selectedRows, property, active);
                    this.selectedRows = [];
                }
                eventValue = {
                    selectedRows: this.selectedRows,
                    changedRow: 'all'
                };
                break;
        }
        this.gtEvent.emit({
            name: 'gt-row-' + eventName,
            value: eventValue
        });
    }
    /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param {?} row - row object.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?=} propertyValues - optional property values that can be passed.
     * @return {?}
     */
    _toggleRowProperty(row, property, propertyValues) {
        let /** @type {?} */ eventName;
        let /** @type {?} */ eventValue;
        // make sure gtRowId exists on row object
        if (typeof row.$$gtRowId !== 'undefined') {
            // check if meta info exists for row
            if (!this.metaInfo[row.$$gtRowId]) {
                // if not, add object to store meta info
                this.metaInfo[row.$$gtRowId] = {};
            }
            switch (property) {
                case 'isOpen':
                    const /** @type {?} */ opened = this.metaInfo[row.$$gtRowId][property];
                    // check if multiple expanded rows are allowed...
                    if (this._gtOptions.rowExpandAllowMultiple === false) {
                        // ...if not, collapse all rows except current row
                        this._updateMetaInfo(this.openRows, property, false, row);
                        this.openRows = [];
                    }
                    // check if row is expanded
                    if (!opened) {
                        eventName = 'expand';
                        // add row to expanded rows
                        this.openRows.push(row);
                    }
                    else {
                        eventName = 'collapse';
                        // loop through expanded rows...
                        for (let /** @type {?} */ i = 0; i < this.openRows.length; i++) {
                            // if expanded row equals passed row...
                            if (this.openRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from expanded rows...
                                this.openRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        expandedRows: this.openRows,
                        changedRow: row
                    };
                    break;
                case 'isSelected':
                    const /** @type {?} */ selected = this.metaInfo[row.$$gtRowId][property];
                    // check if multi row selection is allowed...
                    if (this._gtOptions.rowSelectionAllowMultiple === false) {
                        // ...if not, deselect all rows except current row
                        this._updateMetaInfo(this.selectedRows, property, false, row);
                        this.selectedRows = [];
                    }
                    // check if row is selected
                    if (!selected) {
                        eventName = 'select';
                        // add row to selected rows
                        this.selectedRows.push(row);
                    }
                    else {
                        if (this.gtOptions.lazyLoad && this.lazyAllSelected) {
                            this.lazyAllSelected = false;
                        }
                        eventName = 'deselect';
                        // loop through selected rows...
                        for (let /** @type {?} */ i = 0; i < this.selectedRows.length; i++) {
                            // if selected row equals passed row...
                            if (this.selectedRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from selected rows...
                                this.selectedRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        selectedRows: this.selectedRows,
                        changedRow: row
                    };
                    break;
                case 'isUpdated':
                    eventName = 'updated';
                    const /** @type {?} */ oldValue = propertyValues;
                    // check if edit object exists for row
                    if (typeof this.metaInfo[row.$$gtRowId][property] === 'undefined') {
                        this.metaInfo[row.$$gtRowId][property] = {
                            originalValue: oldValue,
                            oldValue: oldValue,
                            newValue: row
                        };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId][property].oldValue = oldValue;
                        this.metaInfo[row.$$gtRowId][property].newValue = row;
                    }
                    eventValue = this.metaInfo[row.$$gtRowId][property];
                    this.redraw();
                    this.inlineEditCancel(row);
                    // this.gtData = [...this.gtData.map((r) => { return{...r}; })];
                    break;
            }
            this.gtEvent.emit({
                name: 'gt-row-' + eventName,
                value: eventValue
            });
            if (property !== 'isUpdated') {
                this.metaInfo[row.$$gtRowId][property] = !this.metaInfo[row.$$gtRowId][property];
            }
        }
    }
    /**
     * Update column.
     * @param {?} $event - key up event.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    gtUpdateColumn($event, row, column) {
        this._editRow(row, column);
    }
    /**
     * Dropdown select.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    gtDropdownSelect(row, column) {
        const /** @type {?} */ oldValue = Object.assign({}, row);
        row[column.objectKey] = column.renderValue;
        this.updateRow(row, oldValue);
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    _editRow(row, column) {
        const /** @type {?} */ OBJECT_KEY = column.objectKey; // declare object key which contains changes
        // check if cell has changed value
        column.edited = row[column.objectKey] !== column.renderValue;
        // check if row contains changes...
        if (!this.editedRows[row.$$gtRowId]) {
            // if not, create an object for the changed row
            this.editedRows[row.$$gtRowId] = {
                changes: {},
                // create placeholder for changes
                row: row // store reference to the row that should be updated
            };
        }
        // store changed column under changes if it has been edited
        if (column.edited) {
            this.editedRows[row.$$gtRowId].changes[OBJECT_KEY] = column;
        }
        else {
            // delete change object if column is unchanged
            delete this.editedRows[row.$$gtRowId].changes[OBJECT_KEY];
            // check how many columns have been changed
            const /** @type {?} */ CHANGED_COLUMNS = Object.keys(this.editedRows[row.$$gtRowId].changes).length;
            if (CHANGED_COLUMNS === 0) {
                // delete row from edited rows if no columns have been edited
                delete this.editedRows[row.$$gtRowId];
            }
        }
        // if no listener is present...
        if (!this.globalInlineEditListener) {
            // ...listen for update event
            this._listenForKeydownEvent();
        }
    }
    /**
     * Listen for key down event - listen for key down event during inline edit.
     * @return {?}
     */
    _listenForKeydownEvent() {
        // add global listener for key down events
        this.globalInlineEditListener = this.renderer.listen('document', 'keydown', $event => {
            switch ($event.key) {
                case 'Enter': // update data object
                    // update data object
                    this.inlineEditUpdate();
                    break;
                case 'Escape': // cancel
                    // cancel
                    this.inlineEditCancel();
                    break;
            }
        });
    }
    /**
     * Inline edit update - accept changes and update row values.
     * @return {?}
     */
    inlineEditUpdate() {
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(key => {
            const /** @type {?} */ ROW = this.editedRows[key].row; // row to update
            const /** @type {?} */ CHANGES = this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(objectKey => {
                const /** @type {?} */ oldValue = Object.assign({}, ROW);
                ROW[objectKey] = CHANGES[objectKey].renderValue; // update data value
                this.updateRow(ROW, oldValue); // update meta info for row and send event
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    }
    /**
     * Inline edit cancel - cancel and reset inline edits.
     * @param {?=} row
     * @return {?}
     */
    inlineEditCancel(row) {
        if (row) {
            delete this.editedRows[row.$$gtRowId];
            // remove listener
            this._stopListeningForKeydownEvent();
            return;
        }
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(key => {
            const /** @type {?} */ ROW = this.editedRows[key].row; // row to update
            const /** @type {?} */ CHANGES = this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(objectKey => {
                CHANGES[objectKey].renderValue = ROW[objectKey]; // reset rendered value
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    }
    /**
     * Stop listening for key down event - stop listening for key down events passed during inline edit.
     * @return {?}
     */
    _stopListeningForKeydownEvent() {
        if (this.globalInlineEditListener) {
            this.globalInlineEditListener();
            this.globalInlineEditListener = null;
        }
    }
    /**
     * Apply filter(s).
     * @param {?} filter - object containing key value pairs, where value should be array of values.
     * @return {?}
     */
    gtApplyFilter(filter) {
        this.gtInfo.filter = filter;
        // go to first page
        this.goToPage(1);
        this.updateTotals();
    }
    /**
     * Clear/remove applied filter(s).
     * @return {?}
     */
    gtClearFilter() {
        this.gtInfo.filter = false;
        this.updateTotals();
        // this.updateRecordRange();
    }
    /**
     * Search
     * @param {?} value - string containing one or more words
     * @return {?}
     */
    gtSearch(value) {
        this.gtInfo.searchTerms = value;
        // always go to first page when searching
        this.goToPage(1);
        this.updateTotals();
    }
    /**
     * Add rows
     * @param {?} rows - rows to add
     * @return {?} new data array.
     */
    gtAdd(rows) {
        this.gtData = [...this.gtData, ...rows];
        return [...this.gtData];
    }
    /**
     * Delete row
     * @param {?} objectKey - object key you want to find match with
     * @param {?} value - the value that should be deleted
     * @param {?=} match - all: delete all matches, first: delete first match (default)
     * @return {?} new data array.
     */
    gtDelete(objectKey, value, match = 'first') {
        if (match === 'first') {
            for (let /** @type {?} */ i = 0; i < this.gtData.length; i++) {
                if (this.gtData[i][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i])) {
                        this.toggleSelect(this.gtData[i]);
                    }
                    this.gtData.splice(i, 1);
                    this.gtData = [...this.gtData];
                    if (match === 'first') {
                        break;
                    }
                }
            }
        }
        else {
            for (let /** @type {?} */ i = this.gtData.length; i > 0; i--) {
                if (this.gtData[i - 1][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i - 1])) {
                        this.toggleSelect(this.gtData[i - 1]);
                    }
                    this.gtData.splice(i - 1, 1);
                    this.gtData = [...this.gtData];
                }
            }
        }
        return [...this.gtData];
    }
    /**
     * Create store to hold previously loaded records.
     * @param {?} records - total number of records in store.
     * @param {?} perPage - how many records to show per page.
     * @return {?} a nested array to hold records per page.
     */
    createStore(records, perPage) {
        const /** @type {?} */ stores = Math.ceil(records / perPage);
        const /** @type {?} */ store = [];
        for (let /** @type {?} */ i = 0; i < stores; i++) {
            store[i] = [];
        }
        return store;
    }
    /**
     * Create placeholders for rows while loading data from back-end.
     * @param {?} perPage - how many records to show per page.
     * @return {?} an array containing empty records to be presented while fetching real data.
     */
    loadingContent(perPage) {
        // create row object
        const /** @type {?} */ rowObject = {
            $$loading: true
        };
        let /** @type {?} */ order = 0;
        // sort settings by column order
        this._gtSettings.sort(this.getColumnOrder);
        // loop through all settings objects...
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            const /** @type {?} */ setting = this._gtSettings[i];
            // ...if column is visible and enabled...
            if (setting.visible !== false && setting.enabled !== false) {
                // ...if first column, set value to loading text otherwise leave it empty
                if (order === 0) {
                    rowObject[setting.objectKey] = this.gtTexts.loading;
                    this.loadingProperty = setting.objectKey;
                }
                else {
                    rowObject[setting.objectKey] = '';
                }
                order++;
            }
            else {
                rowObject[setting.objectKey] = '';
            }
        }
        // create content placeholder
        const /** @type {?} */ contentPlaceholder = [];
        // create equal number of rows as rows per page
        for (let /** @type {?} */ i = 0; i < perPage; i++) {
            // ...add temporary row object
            contentPlaceholder.push(rowObject);
        }
        return contentPlaceholder;
    }
    /**
     * Export data as CSV
     * @param {?=} fileName - optional file name (overrides default file name).
     * @param {?=} useBOM - use BOM (byte order marker).
     * @return {?}
     */
    exportCSV(fileName, useBOM = false) {
        const /** @type {?} */ data = this.data.exportData;
        let /** @type {?} */ csv = '';
        const /** @type {?} */ BOM = '\uFEFF';
        // csv export headers
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            if (this._gtSettings[i].export !== false) {
                csv += this.getProperty(this._gtFields, this._gtSettings[i].objectKey)
                    .name;
                if (i < this._gtSettings.length - 1) {
                    csv += this._gtOptions.csvDelimiter;
                }
            }
        }
        // csv export body
        data.forEach(row => {
            csv += '\n';
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].export !== false) {
                    // get field settings
                    const /** @type {?} */ fieldSetting = this.getProperty(this._gtFields, this._gtSettings[i].objectKey);
                    // get export value, if export function is defined use it otherwise check for value function and as a last resort export raw data
                    let /** @type {?} */ exportValue = fieldSetting.export && typeof fieldSetting.export === 'function'
                        ? fieldSetting.export(row)
                        : fieldSetting.value && typeof fieldSetting.value === 'function'
                            ? fieldSetting.value(row)
                            : row[this._gtSettings[i].objectKey];
                    // escape export value using double quotes (") if export value contains delimiter
                    exportValue =
                        typeof exportValue === 'string' &&
                            exportValue.indexOf(this._gtOptions.csvDelimiter) !== -1
                            ? '"' + exportValue + '"'
                            : exportValue;
                    csv += exportValue;
                    if (i < this._gtSettings.length - 1) {
                        csv += this._gtOptions.csvDelimiter;
                    }
                }
            }
        });
        const /** @type {?} */ blob = new Blob([(useBOM ? BOM : '') + csv], {
            type: 'text/csv;charset=utf-8'
        });
        if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
        }
        else {
            const /** @type {?} */ link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            if (link.download !== undefined) {
                link.setAttribute('href', 'data:text/csv;charset=utf-8,' +
                    encodeURIComponent((useBOM ? BOM : '') + csv)); // URL.createObjectURL(blob));
                link.setAttribute('download', fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
                document.body.appendChild(link);
                link.click();
            }
            else {
                csv = 'data:text/csv;charset=utf-8,' + (useBOM ? BOM : '') + csv;
                window.open(encodeURIComponent(csv));
            }
            document.body.removeChild(link);
        }
        // emit export event
        this.gtEvent.emit({
            name: 'gt-exported-csv',
            value: fileName ? fileName : this.gtTexts.csvDownload + '.csv'
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // if number of row to display from start is set to null or 0...
        if (!this.gtOptions.numberOfRows) {
            // ...change row length
            this.changeRowLength(this.gtOptions.numberOfRows);
        }
        this.restructureSorting();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // if gt texts have changed...
        if (changes['gtTexts']) {
            // ...extend gtOptions default values with values passed into component
            this.gtTexts = /** @type {?} */ (this.extend(this.gtDefaultTexts, this.gtTexts));
        }
        // if lazy loading data and paging information is available...
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            // ...calculate total number of pages
            this.gtInfo.pageTotal = Math.ceil(this.gtInfo.recordsAfterSearch / this.gtInfo.recordLength);
            // ...declare store position
            const /** @type {?} */ storePosition = this.gtInfo.pageCurrent - 1;
            // ...and if store is empty or page length has changed...
            if (this.store.length === 0 ||
                this.store[0].length !== this.gtInfo.recordLength) {
                // ...create store
                this.store = this.createStore(this.gtInfo.recordsAfterSearch, this.gtInfo.recordLength);
            }
            // ...store retrieved data in store at store position
            this.store[storePosition] = this.gtData;
            this.gtInfo.visibleRecords = [...this.gtData]; // add visible rows
            // replace data with store
            this._gtData = this.store;
            this.loading = false;
            this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-info',
                value: this.gtInfo
            });
        }
        else if (this._gtData &&
            this._gtData.length >= 0 &&
            changes['gtData'] &&
            changes['gtData'].previousValue) {
            this.loading = false;
        }
        else if (changes['gtData'] &&
            changes['gtData'].firstChange &&
            this._gtData &&
            this._gtData.length > 0) {
            this.loading = false;
        }
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByFn(index, item) {
        return item.$$gtRowId;
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByColumnFn(index, item) {
        return item.objectKey;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // remove listener
        this._stopListeningForKeydownEvent();
    }
}
GenericTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'generic-table',
                template: `<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length > 0">
  <thead>
  <tr>
    <th class="gt-sort-label" *ngIf="gtOptions.stack">{{gtTexts.sortLabel}}</th>
    <th *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe"
        ngClass="{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{column.sortEnabled ? 'sort-'+column.sort:''}} {{column.sortEnabled && column.sortOrder >= 0  ? 'sort-order-'+column.sortOrder:''}} {{ gtFields | gtColumnClass:column }}"
        (click)="column.sortEnabled ? gtSort(column.objectKey,$event):'';">
      <span *ngIf="!(gtFields | gtProperty:column.objectKey:'header')">{{gtFields | gtProperty:column.objectKey:'name'}}</span>
      <gt-custom-component-factory *ngIf="(gtFields | gtProperty:column.objectKey:'header')"
                                   [type]="(gtFields | gtProperty:column.objectKey:'header')?.type"
                                   [injector]="(gtFields | gtProperty:column.objectKey:'header')?.injector"
                                   [column]="gtFields | gtProperty:column.objectKey:'name'"></gt-custom-component-factory>
      <gt-checkbox *ngIf="(gtFields | gtProperty:column.objectKey:'columnComponent')?.type === 'checkbox'" [checked]="(gtOptions.lazyLoad ? lazyAllSelected:selectedRows.length === gtData.length)" (changed)="toggleAllRows()"></gt-checkbox>
    </th>
  </tr>
  </thead>
  <ng-template
    [ngIf]="gtTotals && (gtOptions.lazyLoad === false ? (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length).length > 0 : gtData.length > 0)">
    <thead class="gt-totals">
    <tr *ngFor="let total of gtTotals | gtTotalsPosition">
      <td *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;"
          ngClass="{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}">
        <span *ngIf="i === 0" class="float-left">{{total.name}}</span><span
        [innerHTML]="total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals"></span>
      </td>
    </tr>
    </thead>
    <tfoot class="gt-totals">
    <tr *ngFor="let total of gtTotals | gtTotalsPosition:'footer'">
      <td *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;"
          ngClass="{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}">
        <span *ngIf="i === 0" class="float-left">{{total.name}}</span><span
        [innerHTML]="total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals"></span>
      </td>
    </tr>
    </tfoot>
  </ng-template>
  <tbody *ngIf="gtData && gtInfo">
  <ng-template class="table-rows" ngFor let-row let-last="last" [ngForTrackBy]="trackByFn"
               [ngForOf]="gtOptions.lazyLoad && gtInfo ? (gtData[gtInfo.pageCurrent-1]) : (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length | gtOrderBy:sortOrder:gtFields:refreshSorting:gtData.length | gtChunk:gtInfo:gtInfo.recordLength:gtInfo.pageCurrent:refreshPageArray:gtData.length:gtEvent:data | gtRowClass:gtFields)">
    <tr [ngClass]="{'row-selected':metaInfo[row.$$gtRowId]?.isSelected, 'row-open':metaInfo[row.$$gtRowId]?.isOpen, 'row-loading':loading, 'row-expandable':gtRowComponent}"
        class="{{row.$$gtRowClass}}"
        (click)="gtOptions.rowSelection ? toggleSelect(row):rowClick(row, $event)">
      <td *ngFor="let column of row | gtRender:gtSettings:gtFields:refreshPipe:loading:gtOptions.highlightSearch:gtInfo.searchTerms;trackBy:trackByColumnFn"
          ngClass="{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{(gtFields | gtProperty:column.objectKey:'inlineEdit') ? 'gt-inline-edit':''}} {{column.edited ? 'gt-edited':''}} {{ gtFields | gtColumnClass:column:row }}">
                        <span class="gt-row-label"
                              *ngIf="gtOptions.stack">{{(gtFields | gtProperty:column.objectKey:'stackedHeading') ? (gtFields | gtProperty:column.objectKey:'stackedHeading') : (gtFields | gtProperty:column.objectKey:'name')}}</span>
        <gt-custom-component-factory *ngIf="column.columnComponent && column.columnComponent.type !== 'checkbox'" class="gt-row-content"
                                     [type]="column.columnComponent.type"
                                     [injector]="column.columnComponent.injector" [row]="row"
                                     [column]="column" (redrawEvent)="redraw($event)"
                                     [searchTerms]="gtInfo.searchTerms"  (searchEvent)="redraw($event)"
                                     (click)="column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''"></gt-custom-component-factory>
        <span *ngIf="!column.columnComponent && (!(gtFields | gtProperty:column.objectKey:'inlineEdit') || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || (!((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe)))"
              class="gt-row-content" [innerHTML]="column.renderValue"
              (click)="column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''"></span>
        <ng-template
          [ngIf]="!column.columnComponent && (((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe))">
          <ng-template [ngIf]="([true,'email','number','password', 'text'].indexOf((gtFields | gtProperty:column.objectKey:'inlineEdit').type) !== -1) || !(gtFields | gtProperty:column.objectKey:'inlineEdit').type">
            <input class="inline-edit" [attr.type]="!(gtFields | gtProperty:column.objectKey:'inlineEdit').type ? 'text' : !((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type:(gtFields | gtProperty:column.objectKey:'inlineEdit').type | async" [(ngModel)]="column.renderValue"
                   (input)="gtUpdateColumn($event,row, column)">
            <span class="gt-inline-edit-notice">{{gtTexts.inlineEditEdited}}</span>
          </ng-template>
          <gt-dropdown
            *ngIf="(((gtFields | gtProperty:column.objectKey:'inlineEdit').type) && ((gtFields | gtProperty:column.objectKey:'inlineEdit').type).length > 0) || ((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable)"
            [options]="!((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type : (gtFields | gtProperty:column.objectKey:'inlineEdit').type | async"
            [id]="'_' + row.$$gtRowId + '_' + column.objectKey"
            [(selected)]="column.renderValue" (selectedChange)="gtDropdownSelect(row, column)">Add
            inline editing module
          </gt-dropdown>
        </ng-template>
        <ng-template [ngIf]="!column.columnComponent && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active) ">
          <ng-template
            [ngIf]="[true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') !== -1">
            <input class="inline-edit" [attr.type]="(gtFields | gtProperty:column.objectKey:'inlineEdit') === true ? 'text':(gtFields | gtProperty:column.objectKey:'inlineEdit')" [(ngModel)]="column.renderValue"
                   (input)="gtUpdateColumn($event,row, column)">
            <span class="gt-inline-edit-notice">{{gtTexts.inlineEditEdited}}</span>
          </ng-template>
          <gt-dropdown
            *ngIf="(gtFields | gtProperty:column.objectKey:'inlineEdit') && [true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') === -1"
            [options]="gtFields | gtProperty:column.objectKey:'inlineEdit'"
            [id]="'_' + row.$$gtRowId + '_' + column.objectKey"
            [(selected)]="column.renderValue" (selectedChange)="gtDropdownSelect(row, column)">Add
            inline editing module
          </gt-dropdown>
        </ng-template>
        <gt-checkbox *ngIf="column.columnComponent && column.columnComponent.type === 'checkbox'" [checked]="metaInfo[row.$$gtRowId]?.isSelected" (changed)="toggleSelect(row)"></gt-checkbox>
      </td>
    </tr>
    <tr class="row-expanded" *ngIf="metaInfo[row.$$gtRowId]?.isOpen">
      <td [attr.colspan]="(gtFields | gtVisible:gtSettings:refreshPipe).length">
        <gt-expanding-row [row]="row"
                          [type]="expandedRow.component ? expandedRow.component:gtRowComponent"
                          [columnWidth]="columnWidth"
                          [gtFields]="gtFields"
                          [gtOptions]="gtOptions"
                          [gtEvent]="gtEvent"
                          [gtInfo]="gtInfo"
                          [gtSettings]="gtSettings"
                          [data]="expandedRow.data ? expandedRow.data:row"
                          (redrawEvent)="redraw($event)"
                          (toggleRowEvent)="toggleCollapse($event)"></gt-expanding-row>
      </td>
    </tr>
    <tr *ngIf="gtOptions.reportColumnWidth && last">
      <td style="padding: 0; border:none;"
          *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe" gtColumnWidth
          [objectKey]="column.objectKey" [widths]="columnWidth"></td>
    </tr>
  </ng-template>
  <tr *ngIf="gtInfo.pageTotal === 0 && (gtInfo.searchTerms || gtInfo.filter) && !loading">
    <td class="gt-no-matching-results" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">
      {{gtTexts.noMatchingData}}
    </td>
  </tr>
  <tr *ngIf="gtInfo.pageTotal === 0 && !(gtInfo.searchTerms || gtInfo.filter) && !loading">
    <td class="gt-no-results" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">{{gtTexts.noData}}
    </td>
  </tr>
  <tr *ngIf="gtInfo.pageTotal === 0 && loading">
    <td class="gt-loading-data" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">{{gtTexts.loading}}</td>
  </tr>
  </tbody>
</table>
<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length === 0">
  <thead>
  <tr>
    <th class="gt-no-visible-columns">{{gtTexts.noVisibleColumnsHeading}}</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="gt-no-visible-columns">{{gtTexts.noVisibleColumns}}</td>
  </tr>
  </tbody>
</table>
<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="!gtFields || !gtSettings">
  <thead>
  <tr>
    <th class="gt-loading-config">&nbsp;</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="gt-loading-config">&nbsp;</td>
  </tr>
  </tbody>
</table>
`
            },] },
];
/** @nocollapse */
GenericTableComponent.ctorParameters = () => [
    { type: Renderer2, },
    { type: GtMetaPipe, },
];
GenericTableComponent.propDecorators = {
    "gtOptions": [{ type: Input },],
    "gtTotals": [{ type: Input },],
    "gtFields": [{ type: Input },],
    "gtSettings": [{ type: Input },],
    "gtData": [{ type: Input },],
    "gtRowComponent": [{ type: Input },],
    "gtTexts": [{ type: Input },],
    "gtClasses": [{ type: Input },],
    "gtEvent": [{ type: Output },],
    "gtInfo": [{ type: Input },],
};
function GenericTableComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    GenericTableComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    GenericTableComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    GenericTableComponent.propDecorators;
    /** @type {?} */
    GenericTableComponent.prototype.columnWidth;
    /** @type {?} */
    GenericTableComponent.prototype.configObject;
    /** @type {?} */
    GenericTableComponent.prototype.sortOrder;
    /** @type {?} */
    GenericTableComponent.prototype.metaInfo;
    /** @type {?} */
    GenericTableComponent.prototype.selectedRows;
    /** @type {?} */
    GenericTableComponent.prototype.openRows;
    /** @type {?} */
    GenericTableComponent.prototype._gtSettings;
    /** @type {?} */
    GenericTableComponent.prototype._gtFields;
    /** @type {?} */
    GenericTableComponent.prototype._gtData;
    /** @type {?} */
    GenericTableComponent.prototype._gtTotals;
    /** @type {?} */
    GenericTableComponent.prototype._gtRowComponent;
    /** @type {?} */
    GenericTableComponent.prototype.expandedRow;
    /** @type {?} */
    GenericTableComponent.prototype.gtDefaultTexts;
    /** @type {?} */
    GenericTableComponent.prototype.gtTexts;
    /** @type {?} */
    GenericTableComponent.prototype.gtClasses;
    /** @type {?} */
    GenericTableComponent.prototype.gtEvent;
    /** @type {?} */
    GenericTableComponent.prototype.gtDefaultOptions;
    /** @type {?} */
    GenericTableComponent.prototype._gtOptions;
    /** @type {?} */
    GenericTableComponent.prototype.store;
    /** @type {?} */
    GenericTableComponent.prototype.loading;
    /** @type {?} */
    GenericTableComponent.prototype.debounceTimer;
    /** @type {?} */
    GenericTableComponent.prototype.loadingProperty;
    /** @type {?} */
    GenericTableComponent.prototype.lazyAllSelected;
    /** @type {?} */
    GenericTableComponent.prototype.gtInfo;
    /** @type {?} */
    GenericTableComponent.prototype.refreshPipe;
    /** @type {?} */
    GenericTableComponent.prototype.refreshTotals;
    /** @type {?} */
    GenericTableComponent.prototype.refreshSorting;
    /** @type {?} */
    GenericTableComponent.prototype.refreshFilter;
    /** @type {?} */
    GenericTableComponent.prototype.refreshPageArray;
    /** @type {?} */
    GenericTableComponent.prototype.globalInlineEditListener;
    /** @type {?} */
    GenericTableComponent.prototype.editedRows;
    /** @type {?} */
    GenericTableComponent.prototype.data;
    /**
     * Sort table by object key.
     * \@param objectKey - name of key to sort on.
     * \@param event - such as key press during sorting.
     * @type {?}
     */
    GenericTableComponent.prototype.gtSort;
    /**
     * Change number of rows to be displayed.
     * \@param rowLength - total number of rows.
     * \@param reset - should page be reset to first page.
     * @type {?}
     */
    GenericTableComponent.prototype.changeRowLength;
    /**
     * Force a redraw of table rows.
     * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
     * @type {?}
     */
    GenericTableComponent.prototype.redraw;
    /**
     * Go to next page.
     * @type {?}
     */
    GenericTableComponent.prototype.nextPage;
    /**
     * Go to previous page.
     * @type {?}
     */
    GenericTableComponent.prototype.previousPage;
    /**
     * Request more data (used when lazy loading)
     * @type {?}
     */
    GenericTableComponent.prototype.getData;
    /**
     * Go to specific page.
     * \@param page - page number.
     * @type {?}
     */
    GenericTableComponent.prototype.goToPage;
    /**
     * Sort by sort order
     * @type {?}
     */
    GenericTableComponent.prototype.getSortOrder;
    /**
     * Sort by column order
     * @type {?}
     */
    GenericTableComponent.prototype.getColumnOrder;
    /**
     * Create a deep copy of data
     * @type {?}
     */
    GenericTableComponent.prototype.cloneDeep;
    /**
     * Return property
     * @type {?}
     */
    GenericTableComponent.prototype.getProperty;
    /** @type {?} */
    GenericTableComponent.prototype.restructureSorting;
    /**
     *  Extend object function.
     * @type {?}
     */
    GenericTableComponent.prototype.extend;
    /** @type {?} */
    GenericTableComponent.prototype.renderer;
    /** @type {?} */
    GenericTableComponent.prototype.gtMetaPipe;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpYy10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvIiwic291cmNlcyI6WyJjb21wb25lbnRzL2dlbmVyaWMtdGFibGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ04sU0FBUyxFQUdULE1BQU0sRUFDTixLQUFLLEVBQ0wsWUFBWSxFQUNaLElBQUksRUFFSixTQUFTLEVBRVQsTUFBTSxlQUFlLENBQUM7QUFjdkIsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7Ozs7QUE2Sm5ELE1BQU07Ozs7O0lBd1FMLFlBQW9CLFFBQW1CLEVBQVUsVUFBc0I7UUFBbkQsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUFVLGVBQVUsR0FBVixVQUFVLENBQVk7MkJBbkYxQyxFQUFFO3lCQUVBLEVBQUU7d0JBQ21CLEVBQUU7NEJBQ2xCLEVBQUU7d0JBQ04sRUFBRTsyQkFDTyxFQUFFO3lCQUNFLEVBQUU7OEJBUWQ7WUFDaEMsT0FBTyxFQUFFLFlBQVk7WUFDckIsTUFBTSxFQUFFLFNBQVM7WUFDakIsY0FBYyxFQUFFLGdDQUFnQztZQUNoRCx1QkFBdUIsRUFBRSxvQkFBb0I7WUFDN0MsZ0JBQWdCLEVBQUUsa0RBQWtEO1lBQ3BFLFNBQVMsRUFDUixrRUFBa0U7WUFDbkUsb0JBQW9CLEVBQ25CLGtIQUFrSDtZQUNuSCxXQUFXLEVBQUUsVUFBVTtZQUN2QixTQUFTLEVBQUUsT0FBTztZQUNsQixZQUFZLEVBQUUsV0FBVztZQUN6QixnQkFBZ0IsRUFBRSxlQUFlO1lBQ2pDLGdCQUFnQixFQUFFLHFCQUFxQjtTQUN2Qzt1QkFDMkIsSUFBSSxDQUFDLGNBQWM7dUJBRUosSUFBSSxZQUFZLEVBQUU7Z0NBQ3hCO1lBQ3BDLFlBQVksRUFBRSxHQUFHO1lBQ2pCLEtBQUssRUFBRSxLQUFLO1lBQ1osUUFBUSxFQUFFLEtBQUs7WUFDZixLQUFL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Qzs7O1lBcm5ERCxTQUFTLFNBQUM7Z0JBQ1YsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVKVjthQUNBOzs7O1lBNUtBLFNBQVM7WUFnQkQsVUFBVTs7OzBCQTJMakIsS0FBSzt5QkFxQkwsS0FBSzt5QkFJTCxLQUFLOzJCQWNMLEtBQUs7dUJBeUNMLEtBQUs7K0JBK0RMLEtBQUs7d0JBdUNMLEtBQUs7MEJBQ0wsS0FBSzt3QkFDTCxNQUFNO3VCQXVCTixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuXHRDb21wb25lbnQsXHJcblx0T25Jbml0LFxyXG5cdE9uQ2hhbmdlcyxcclxuXHRPdXRwdXQsXHJcblx0SW5wdXQsXHJcblx0RXZlbnRFbWl0dGVyLFxyXG5cdFR5cGUsXHJcblx0U2ltcGxlQ2hhbmdlcyxcclxuXHRSZW5kZXJlcjIsXHJcblx0T25EZXN0cm95XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcblx0R3RDb25maWcsXHJcblx0R3RDb25maWdGaWVsZCxcclxuXHRHdENvbmZpZ1NldHRpbmcsXHJcblx0R3RUZXh0cyxcclxuXHRHdEluZm9ybWF0aW9uLFxyXG5cdEd0RXhwYW5kZWRSb3csXHJcblx0R3RSb3csXHJcblx0R3RPcHRpb25zLFxyXG5cdEd0Um93TWV0YSxcclxuXHRHdFJlbmRlckZpZWxkLFxyXG5cdEd0RXZlbnRcclxufSBmcm9tICcuLic7XHJcbmltcG9ydCB7IEd0TWV0YVBpcGUgfSBmcm9tICcuLi9waXBlcy9ndC1tZXRhLnBpcGUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcblx0c2VsZWN0b3I6ICdnZW5lcmljLXRhYmxlJyxcclxuXHR0ZW1wbGF0ZTogYDx0YWJsZSBjbGFzcz1cInRhYmxlXCIgbmdDbGFzcz1cInt7Z3RDbGFzc2VzfX0ge3tndE9wdGlvbnMuc3RhY2sgPyAndGFibGUtc3RhY2tlZCc6Jyd9fVwiXHJcbiAgICAgICAqbmdJZj1cImd0RmllbGRzICYmIGd0U2V0dGluZ3MgJiYgKGd0RmllbGRzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3M6cmVmcmVzaFBpcGUpLmxlbmd0aCA+IDBcIj5cclxuICA8dGhlYWQ+XHJcbiAgPHRyPlxyXG4gICAgPHRoIGNsYXNzPVwiZ3Qtc29ydC1sYWJlbFwiICpuZ0lmPVwiZ3RPcHRpb25zLnN0YWNrXCI+e3tndFRleHRzLnNvcnRMYWJlbH19PC90aD5cclxuICAgIDx0aCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZVwiXHJcbiAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy1jb2x1bW4nIHwgZGFzaENhc2V9fSB7e2d0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidjbGFzc05hbWVzJ319IHt7Y29sdW1uLnNvcnRFbmFibGVkID8gJ3NvcnQtJytjb2x1bW4uc29ydDonJ319IHt7Y29sdW1uLnNvcnRFbmFibGVkICYmIGNvbHVtbi5zb3J0T3JkZXIgPj0gMCAgPyAnc29ydC1vcmRlci0nK2NvbHVtbi5zb3J0T3JkZXI6Jyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6Y29sdW1uIH19XCJcclxuICAgICAgICAoY2xpY2spPVwiY29sdW1uLnNvcnRFbmFibGVkID8gZ3RTb3J0KGNvbHVtbi5vYmplY3RLZXksJGV2ZW50KTonJztcIj5cclxuICAgICAgPHNwYW4gKm5nSWY9XCIhKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKVwiPnt7Z3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnfX08L3NwYW4+XHJcbiAgICAgIDxndC1jdXN0b20tY29tcG9uZW50LWZhY3RvcnkgKm5nSWY9XCIoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2hlYWRlcicpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCIoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2hlYWRlcicpPy50eXBlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaW5qZWN0b3JdPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKT8uaW5qZWN0b3JcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnXCI+PC9ndC1jdXN0b20tY29tcG9uZW50LWZhY3Rvcnk+XHJcbiAgICAgIDxndC1jaGVja2JveCAqbmdJZj1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY29sdW1uQ29tcG9uZW50Jyk/LnR5cGUgPT09ICdjaGVja2JveCdcIiBbY2hlY2tlZF09XCIoZ3RPcHRpb25zLmxhenlMb2FkID8gbGF6eUFsbFNlbGVjdGVkOnNlbGVjdGVkUm93cy5sZW5ndGggPT09IGd0RGF0YS5sZW5ndGgpXCIgKGNoYW5nZWQpPVwidG9nZ2xlQWxsUm93cygpXCI+PC9ndC1jaGVja2JveD5cclxuICAgIDwvdGg+XHJcbiAgPC90cj5cclxuICA8L3RoZWFkPlxyXG4gIDxuZy10ZW1wbGF0ZVxyXG4gICAgW25nSWZdPVwiZ3RUb3RhbHMgJiYgKGd0T3B0aW9ucy5sYXp5TG9hZCA9PT0gZmFsc2UgPyAoZ3REYXRhIHwgZ3RGaWx0ZXI6Z3RJbmZvLmZpbHRlcjpndEluZm86cmVmcmVzaEZpbHRlcjpndERhdGEubGVuZ3RoIHwgZ3RTZWFyY2g6Z3RJbmZvLnNlYXJjaFRlcm1zOmd0SW5mbzpndFNldHRpbmdzOmd0RmllbGRzOmd0RGF0YS5sZW5ndGgpLmxlbmd0aCA+IDAgOiBndERhdGEubGVuZ3RoID4gMClcIj5cclxuICAgIDx0aGVhZCBjbGFzcz1cImd0LXRvdGFsc1wiPlxyXG4gICAgPHRyICpuZ0Zvcj1cImxldCB0b3RhbCBvZiBndFRvdGFscyB8IGd0VG90YWxzUG9zaXRpb25cIj5cclxuICAgICAgPHRkICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgZ3RTZXR0aW5ncyB8IGd0VmlzaWJsZTpndFNldHRpbmdzOnJlZnJlc2hQaXBlO2xldCBpID0gaW5kZXg7XCJcclxuICAgICAgICAgIG5nQ2xhc3M9XCJ7e2NvbHVtbi5vYmplY3RLZXkgKyctdG90YWxzLWNvbHVtbicgfCBkYXNoQ2FzZX19IHt7Z3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2NsYXNzTmFtZXMnfX0ge3sgZ3RGaWVsZHMgfCBndENvbHVtbkNsYXNzOmNvbHVtbiB9fVwiPlxyXG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaSA9PT0gMFwiIGNsYXNzPVwiZmxvYXQtbGVmdFwiPnt7dG90YWwubmFtZX19PC9zcGFuPjxzcGFuXHJcbiAgICAgICAgW2lubmVySFRNTF09XCJ0b3RhbC5maWVsZHNbY29sdW1uLm9iamVjdEtleV0gfCBndFRvdGFsczoodG90YWwudXBkYXRlID09PSBmYWxzZSB8fCBndE9wdGlvbnMubGF6eUxvYWQgPT09IHRydWUpID8gZ3REYXRhOihndERhdGEgfCBndEZpbHRlcjpndEluZm8uZmlsdGVyOmd0SW5mbzpyZWZyZXNoRmlsdGVyOmd0RGF0YS5sZW5ndGggfCBndFNlYXJjaDpndEluZm8uc2VhcmNoVGVybXM6Z3RJbmZvOmd0U2V0dGluZ3M6Z3RGaWVsZHM6Z3REYXRhLmxlbmd0aCk6Y29sdW1uLm9iamVjdEtleTpyZWZyZXNoVG90YWxzXCI+PC9zcGFuPlxyXG4gICAgICA8L3RkPlxyXG4gICAgPC90cj5cclxuICAgIDwvdGhlYWQ+XHJcbiAgICA8dGZvb3QgY2xhc3M9XCJndC10b3RhbHNcIj5cclxuICAgIDx0ciAqbmdGb3I9XCJsZXQgdG90YWwgb2YgZ3RUb3RhbHMgfCBndFRvdGFsc1Bvc2l0aW9uOidmb290ZXInXCI+XHJcbiAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZTtsZXQgaSA9IGluZGV4O1wiXHJcbiAgICAgICAgICBuZ0NsYXNzPVwie3tjb2x1bW4ub2JqZWN0S2V5ICsnLXRvdGFscy1jb2x1bW4nIHwgZGFzaENhc2V9fSB7e2d0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidjbGFzc05hbWVzJ319IHt7IGd0RmllbGRzIHwgZ3RDb2x1bW5DbGFzczpjb2x1bW4gfX1cIj5cclxuICAgICAgICA8c3BhbiAqbmdJZj1cImkgPT09IDBcIiBjbGFzcz1cImZsb2F0LWxlZnRcIj57e3RvdGFsLm5hbWV9fTwvc3Bhbj48c3BhblxyXG4gICAgICAgIFtpbm5lckhUTUxdPVwidG90YWwuZmllbGRzW2NvbHVtbi5vYmplY3RLZXldIHwgZ3RUb3RhbHM6KHRvdGFsLnVwZGF0ZSA9PT0gZmFsc2UgfHwgZ3RPcHRpb25zLmxhenlMb2FkID09PSB0cnVlKSA/IGd0RGF0YTooZ3REYXRhIHwgZ3RGaWx0ZXI6Z3RJbmZvLmZpbHRlcjpndEluZm86cmVmcmVzaEZpbHRlcjpndERhdGEubGVuZ3RoIHwgZ3RTZWFyY2g6Z3RJbmZvLnNlYXJjaFRlcm1zOmd0SW5mbzpndFNldHRpbmdzOmd0RmllbGRzOmd0RGF0YS5sZW5ndGgpOmNvbHVtbi5vYmplY3RLZXk6cmVmcmVzaFRvdGFsc1wiPjwvc3Bhbj5cclxuICAgICAgPC90ZD5cclxuICAgIDwvdHI+XHJcbiAgICA8L3Rmb290PlxyXG4gIDwvbmctdGVtcGxhdGU+XHJcbiAgPHRib2R5ICpuZ0lmPVwiZ3REYXRhICYmIGd0SW5mb1wiPlxyXG4gIDxuZy10ZW1wbGF0ZSBjbGFzcz1cInRhYmxlLXJvd3NcIiBuZ0ZvciBsZXQtcm93IGxldC1sYXN0PVwibGFzdFwiIFtuZ0ZvclRyYWNrQnldPVwidHJhY2tCeUZuXCJcclxuICAgICAgICAgICAgICAgW25nRm9yT2ZdPVwiZ3RPcHRpb25zLmxhenlMb2FkICYmIGd0SW5mbyA/IChndERhdGFbZ3RJbmZvLnBhZ2VDdXJyZW50LTFdKSA6IChndERhdGEgfCBndEZpbHRlcjpndEluZm8uZmlsdGVyOmd0SW5mbzpyZWZyZXNoRmlsdGVyOmd0RGF0YS5sZW5ndGggfCBndFNlYXJjaDpndEluZm8uc2VhcmNoVGVybXM6Z3RJbmZvOmd0U2V0dGluZ3M6Z3RGaWVsZHM6Z3REYXRhLmxlbmd0aCB8IGd0T3JkZXJCeTpzb3J0T3JkZXI6Z3RGaWVsZHM6cmVmcmVzaFNvcnRpbmc6Z3REYXRhLmxlbmd0aCB8IGd0Q2h1bms6Z3RJbmZvOmd0SW5mby5yZWNvcmRMZW5ndGg6Z3RJbmZvLnBhZ2VDdXJyZW50OnJlZnJlc2hQYWdlQXJyYXk6Z3REYXRhLmxlbmd0aDpndEV2ZW50OmRhdGEgfCBndFJvd0NsYXNzOmd0RmllbGRzKVwiPlxyXG4gICAgPHRyIFtuZ0NsYXNzXT1cInsncm93LXNlbGVjdGVkJzptZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNTZWxlY3RlZCwgJ3Jvdy1vcGVuJzptZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNPcGVuLCAncm93LWxvYWRpbmcnOmxvYWRpbmcsICdyb3ctZXhwYW5kYWJsZSc6Z3RSb3dDb21wb25lbnR9XCJcclxuICAgICAgICBjbGFzcz1cInt7cm93LiQkZ3RSb3dDbGFzc319XCJcclxuICAgICAgICAoY2xpY2spPVwiZ3RPcHRpb25zLnJvd1NlbGVjdGlvbiA/IHRvZ2dsZVNlbGVjdChyb3cpOnJvd0NsaWNrKHJvdywgJGV2ZW50KVwiPlxyXG4gICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiByb3cgfCBndFJlbmRlcjpndFNldHRpbmdzOmd0RmllbGRzOnJlZnJlc2hQaXBlOmxvYWRpbmc6Z3RPcHRpb25zLmhpZ2hsaWdodFNlYXJjaDpndEluZm8uc2VhcmNoVGVybXM7dHJhY2tCeTp0cmFja0J5Q29sdW1uRm5cIlxyXG4gICAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy1jb2x1bW4nIHwgZGFzaENhc2V9fSB7e2d0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidjbGFzc05hbWVzJ319IHt7KGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykgPyAnZ3QtaW5saW5lLWVkaXQnOicnfX0ge3tjb2x1bW4uZWRpdGVkID8gJ2d0LWVkaXRlZCc6Jyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6Y29sdW1uOnJvdyB9fVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImd0LXJvdy1sYWJlbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZ3RPcHRpb25zLnN0YWNrXCI+e3soZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgPyAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgOiAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnKX19PC9zcGFuPlxyXG4gICAgICAgIDxndC1jdXN0b20tY29tcG9uZW50LWZhY3RvcnkgKm5nSWY9XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmIGNvbHVtbi5jb2x1bW5Db21wb25lbnQudHlwZSAhPT0gJ2NoZWNrYm94J1wiIGNsYXNzPVwiZ3Qtcm93LWNvbnRlbnRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3R5cGVdPVwiY29sdW1uLmNvbHVtbkNvbXBvbmVudC50eXBlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbmplY3Rvcl09XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50LmluamVjdG9yXCIgW3Jvd109XCJyb3dcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIiAocmVkcmF3RXZlbnQpPVwicmVkcmF3KCRldmVudClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlYXJjaFRlcm1zXT1cImd0SW5mby5zZWFyY2hUZXJtc1wiICAoc2VhcmNoRXZlbnQpPVwicmVkcmF3KCRldmVudClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNvbHVtbi5jbGljayA/IGNvbHVtbi5jbGljayhyb3csY29sdW1uLCRldmVudCk6Jyc7Y29sdW1uLmV4cGFuZCA/IHRvZ2dsZUNvbGxhcHNlKHJvdywgY29sdW1uLmV4cGFuZCk6JydcIj48L2d0LWN1c3RvbS1jb21wb25lbnQtZmFjdG9yeT5cclxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmICghKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykgfHwgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpPy5hY3RpdmUgfCBndElzT2JzZXJ2YWJsZSkgJiYgISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgYXN5bmMpIHx8ICghKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpPy5hY3RpdmUgfCBndElzT2JzZXJ2YWJsZSkgJiYgISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc0VkaXRhYmxlOnJvdzpyZWZyZXNoUGlwZSkpKVwiXHJcbiAgICAgICAgICAgICAgY2xhc3M9XCJndC1yb3ctY29udGVudFwiIFtpbm5lckhUTUxdPVwiY29sdW1uLnJlbmRlclZhbHVlXCJcclxuICAgICAgICAgICAgICAoY2xpY2spPVwiY29sdW1uLmNsaWNrID8gY29sdW1uLmNsaWNrKHJvdyxjb2x1bW4sJGV2ZW50KTonJztjb2x1bW4uZXhwYW5kID8gdG9nZ2xlQ29sbGFwc2Uocm93LCBjb2x1bW4uZXhwYW5kKTonJ1wiPjwvc3Bhbj5cclxuICAgICAgICA8bmctdGVtcGxhdGVcclxuICAgICAgICAgIFtuZ0lmXT1cIiFjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmICgoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSB8IGd0SXNPYnNlcnZhYmxlKSAmJiAoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSB8IGFzeW5jKSB8fCAoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSB8IGd0SXNFZGl0YWJsZTpyb3c6cmVmcmVzaFBpcGUpKVwiPlxyXG4gICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIihbdHJ1ZSwnZW1haWwnLCdudW1iZXInLCdwYXNzd29yZCcsICd0ZXh0J10uaW5kZXhPZigoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlKSAhPT0gLTEpIHx8ICEoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlXCI+XHJcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlubGluZS1lZGl0XCIgW2F0dHIudHlwZV09XCIhKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSA/ICd0ZXh0JyA6ICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSB8IGd0SXNPYnNlcnZhYmxlKSA/IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGU6KGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSB8IGFzeW5jXCIgWyhuZ01vZGVsKV09XCJjb2x1bW4ucmVuZGVyVmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgKGlucHV0KT1cImd0VXBkYXRlQ29sdW1uKCRldmVudCxyb3csIGNvbHVtbilcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJndC1pbmxpbmUtZWRpdC1ub3RpY2VcIj57e2d0VGV4dHMuaW5saW5lRWRpdEVkaXRlZH19PC9zcGFuPlxyXG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICAgIDxndC1kcm9wZG93blxyXG4gICAgICAgICAgICAqbmdJZj1cIigoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSkgJiYgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUpLmxlbmd0aCA+IDApIHx8ICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlIHwgZ3RJc09ic2VydmFibGUpXCJcclxuICAgICAgICAgICAgW29wdGlvbnNdPVwiISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlIHwgZ3RJc09ic2VydmFibGUpID8gKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSA6IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgfCBhc3luY1wiXHJcbiAgICAgICAgICAgIFtpZF09XCInXycgKyByb3cuJCRndFJvd0lkICsgJ18nICsgY29sdW1uLm9iamVjdEtleVwiXHJcbiAgICAgICAgICAgIFsoc2VsZWN0ZWQpXT1cImNvbHVtbi5yZW5kZXJWYWx1ZVwiIChzZWxlY3RlZENoYW5nZSk9XCJndERyb3Bkb3duU2VsZWN0KHJvdywgY29sdW1uKVwiPkFkZFxyXG4gICAgICAgICAgICBpbmxpbmUgZWRpdGluZyBtb2R1bGVcclxuICAgICAgICAgIDwvZ3QtZHJvcGRvd24+XHJcbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWNvbHVtbi5jb2x1bW5Db21wb25lbnQgJiYgISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlKSBcIj5cclxuICAgICAgICAgIDxuZy10ZW1wbGF0ZVxyXG4gICAgICAgICAgICBbbmdJZl09XCJbdHJ1ZSwnZW1haWwnLCdudW1iZXInLCdwYXNzd29yZCddLmluZGV4T2YoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKSAhPT0gLTFcIj5cclxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiaW5saW5lLWVkaXRcIiBbYXR0ci50eXBlXT1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpID09PSB0cnVlID8gJ3RleHQnOihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpXCIgWyhuZ01vZGVsKV09XCJjb2x1bW4ucmVuZGVyVmFsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgKGlucHV0KT1cImd0VXBkYXRlQ29sdW1uKCRldmVudCxyb3csIGNvbHVtbilcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJndC1pbmxpbmUtZWRpdC1ub3RpY2VcIj57e2d0VGV4dHMuaW5saW5lRWRpdEVkaXRlZH19PC9zcGFuPlxyXG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICAgIDxndC1kcm9wZG93blxyXG4gICAgICAgICAgICAqbmdJZj1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpICYmIFt0cnVlLCdlbWFpbCcsJ251bWJlcicsJ3Bhc3N3b3JkJ10uaW5kZXhPZihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpID09PSAtMVwiXHJcbiAgICAgICAgICAgIFtvcHRpb25zXT1cImd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0J1wiXHJcbiAgICAgICAgICAgIFtpZF09XCInXycgKyByb3cuJCRndFJvd0lkICsgJ18nICsgY29sdW1uLm9iamVjdEtleVwiXHJcbiAgICAgICAgICAgIFsoc2VsZWN0ZWQpXT1cImNvbHVtbi5yZW5kZXJWYWx1ZVwiIChzZWxlY3RlZENoYW5nZSk9XCJndERyb3Bkb3duU2VsZWN0KHJvdywgY29sdW1uKVwiPkFkZFxyXG4gICAgICAgICAgICBpbmxpbmUgZWRpdGluZyBtb2R1bGVcclxuICAgICAgICAgIDwvZ3QtZHJvcGRvd24+XHJcbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICA8Z3QtY2hlY2tib3ggKm5nSWY9XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmIGNvbHVtbi5jb2x1bW5Db21wb25lbnQudHlwZSA9PT0gJ2NoZWNrYm94J1wiIFtjaGVja2VkXT1cIm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdPy5pc1NlbGVjdGVkXCIgKGNoYW5nZWQpPVwidG9nZ2xlU2VsZWN0KHJvdylcIj48L2d0LWNoZWNrYm94PlxyXG4gICAgICA8L3RkPlxyXG4gICAgPC90cj5cclxuICAgIDx0ciBjbGFzcz1cInJvdy1leHBhbmRlZFwiICpuZ0lmPVwibWV0YUluZm9bcm93LiQkZ3RSb3dJZF0/LmlzT3BlblwiPlxyXG4gICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCIoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZSkubGVuZ3RoXCI+XHJcbiAgICAgICAgPGd0LWV4cGFuZGluZy1yb3cgW3Jvd109XCJyb3dcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFt0eXBlXT1cImV4cGFuZGVkUm93LmNvbXBvbmVudCA/IGV4cGFuZGVkUm93LmNvbXBvbmVudDpndFJvd0NvbXBvbmVudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbldpZHRoXT1cImNvbHVtbldpZHRoXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RGaWVsZHNdPVwiZ3RGaWVsZHNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndE9wdGlvbnNdPVwiZ3RPcHRpb25zXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RFdmVudF09XCJndEV2ZW50XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RJbmZvXT1cImd0SW5mb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2d0U2V0dGluZ3NdPVwiZ3RTZXR0aW5nc1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2RhdGFdPVwiZXhwYW5kZWRSb3cuZGF0YSA/IGV4cGFuZGVkUm93LmRhdGE6cm93XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVkcmF3RXZlbnQpPVwicmVkcmF3KCRldmVudClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh0b2dnbGVSb3dFdmVudCk9XCJ0b2dnbGVDb2xsYXBzZSgkZXZlbnQpXCI+PC9ndC1leHBhbmRpbmctcm93PlxyXG4gICAgICA8L3RkPlxyXG4gICAgPC90cj5cclxuICAgIDx0ciAqbmdJZj1cImd0T3B0aW9ucy5yZXBvcnRDb2x1bW5XaWR0aCAmJiBsYXN0XCI+XHJcbiAgICAgIDx0ZCBzdHlsZT1cInBhZGRpbmc6IDA7IGJvcmRlcjpub25lO1wiXHJcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZVwiIGd0Q29sdW1uV2lkdGhcclxuICAgICAgICAgIFtvYmplY3RLZXldPVwiY29sdW1uLm9iamVjdEtleVwiIFt3aWR0aHNdPVwiY29sdW1uV2lkdGhcIj48L3RkPlxyXG4gICAgPC90cj5cclxuICA8L25nLXRlbXBsYXRlPlxyXG4gIDx0ciAqbmdJZj1cImd0SW5mby5wYWdlVG90YWwgPT09IDAgJiYgKGd0SW5mby5zZWFyY2hUZXJtcyB8fCBndEluZm8uZmlsdGVyKSAmJiAhbG9hZGluZ1wiPlxyXG4gICAgPHRkIGNsYXNzPVwiZ3Qtbm8tbWF0Y2hpbmctcmVzdWx0c1wiIFthdHRyLmNvbHNwYW5dPVwiKGd0RmllbGRzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3MpLmxlbmd0aFwiPlxyXG4gICAgICB7e2d0VGV4dHMubm9NYXRjaGluZ0RhdGF9fVxyXG4gICAgPC90ZD5cclxuICA8L3RyPlxyXG4gIDx0ciAqbmdJZj1cImd0SW5mby5wYWdlVG90YWwgPT09IDAgJiYgIShndEluZm8uc2VhcmNoVGVybXMgfHwgZ3RJbmZvLmZpbHRlcikgJiYgIWxvYWRpbmdcIj5cclxuICAgIDx0ZCBjbGFzcz1cImd0LW5vLXJlc3VsdHNcIiBbYXR0ci5jb2xzcGFuXT1cIihndEZpZWxkcyB8IGd0VmlzaWJsZTpndFNldHRpbmdzKS5sZW5ndGhcIj57e2d0VGV4dHMubm9EYXRhfX1cclxuICAgIDwvdGQ+XHJcbiAgPC90cj5cclxuICA8dHIgKm5nSWY9XCJndEluZm8ucGFnZVRvdGFsID09PSAwICYmIGxvYWRpbmdcIj5cclxuICAgIDx0ZCBjbGFzcz1cImd0LWxvYWRpbmctZGF0YVwiIFthdHRyLmNvbHNwYW5dPVwiKGd0RmllbGRzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3MpLmxlbmd0aFwiPnt7Z3RUZXh0cy5sb2FkaW5nfX08L3RkPlxyXG4gIDwvdHI+XHJcbiAgPC90Ym9keT5cclxuPC90YWJsZT5cclxuPHRhYmxlIGNsYXNzPVwidGFibGVcIiBuZ0NsYXNzPVwie3tndENsYXNzZXN9fSB7e2d0T3B0aW9ucy5zdGFjayA/ICd0YWJsZS1zdGFja2VkJzonJ319XCJcclxuICAgICAgICpuZ0lmPVwiZ3RGaWVsZHMgJiYgZ3RTZXR0aW5ncyAmJiAoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZSkubGVuZ3RoID09PSAwXCI+XHJcbiAgPHRoZWFkPlxyXG4gIDx0cj5cclxuICAgIDx0aCBjbGFzcz1cImd0LW5vLXZpc2libGUtY29sdW1uc1wiPnt7Z3RUZXh0cy5ub1Zpc2libGVDb2x1bW5zSGVhZGluZ319PC90aD5cclxuICA8L3RyPlxyXG4gIDwvdGhlYWQ+XHJcbiAgPHRib2R5PlxyXG4gIDx0cj5cclxuICAgIDx0ZCBjbGFzcz1cImd0LW5vLXZpc2libGUtY29sdW1uc1wiPnt7Z3RUZXh0cy5ub1Zpc2libGVDb2x1bW5zfX08L3RkPlxyXG4gIDwvdHI+XHJcbiAgPC90Ym9keT5cclxuPC90YWJsZT5cclxuPHRhYmxlIGNsYXNzPVwidGFibGVcIiBuZ0NsYXNzPVwie3tndENsYXNzZXN9fSB7e2d0T3B0aW9ucy5zdGFjayA/ICd0YWJsZS1zdGFja2VkJzonJ319XCJcclxuICAgICAgICpuZ0lmPVwiIWd0RmllbGRzIHx8ICFndFNldHRpbmdzXCI+XHJcbiAgPHRoZWFkPlxyXG4gIDx0cj5cclxuICAgIDx0aCBjbGFzcz1cImd0LWxvYWRpbmctY29uZmlnXCI+Jm5ic3A7PC90aD5cclxuICA8L3RyPlxyXG4gIDwvdGhlYWQ+XHJcbiAgPHRib2R5PlxyXG4gIDx0cj5cclxuICAgIDx0ZCBjbGFzcz1cImd0LWxvYWRpbmctY29uZmlnXCI+Jm5ic3A7PC90ZD5cclxuICA8L3RyPlxyXG4gIDwvdGJvZHk+XHJcbjwvdGFibGU+XHJcbmBcclxufSlcclxuZXhwb3J0IGNsYXNzIEdlbmVyaWNUYWJsZUNvbXBvbmVudDxSIGV4dGVuZHMgR3RSb3csIEMgZXh0ZW5kcyBHdEV4cGFuZGVkUm93PFI+PlxyXG5cdGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XHJcblx0Z2V0IGd0Um93Q29tcG9uZW50KCk6IFR5cGU8Qz4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2d0Um93Q29tcG9uZW50O1xyXG5cdH1cclxuXHJcblx0Z2V0IGhhc0VkaXRzKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZWRpdGVkUm93cykubGVuZ3RoID4gMDtcclxuXHR9XHJcblxyXG5cdGdldCBndE9wdGlvbnMoKTogR3RPcHRpb25zIHtcclxuXHRcdHJldHVybiB0aGlzLl9ndE9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHRnZXQgZ3RUb3RhbHMoKTogYW55IHtcclxuXHRcdHJldHVybiB0aGlzLl9ndFRvdGFscztcclxuXHR9XHJcblxyXG5cdGdldCBndEZpZWxkcygpOiBHdENvbmZpZ0ZpZWxkPFIsIGFueT5bXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ3RGaWVsZHM7XHJcblx0fVxyXG5cclxuXHRnZXQgZ3RTZXR0aW5ncygpOiBHdENvbmZpZ1NldHRpbmdbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ3RTZXR0aW5ncztcclxuXHR9XHJcblxyXG5cdGdldCBndERhdGEoKTogQXJyYXk8YW55PiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ3REYXRhO1xyXG5cdH1cclxuXHJcblx0QElucHV0KClcclxuXHRzZXQgZ3RPcHRpb25zKHZhbHVlOiBHdE9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2d0T3B0aW9ucyA9IHZhbHVlO1xyXG5cclxuXHRcdC8vIGlmIG51bWJlciBvZiByb3dzIGlzIHBhc3NlZCBhbmQgaWYgbnVtYmVyIG9mIHJvd3MgZGlmZmVycyBmcm9tIGN1cnJlbnQgcmVjb3JkIGxlbmd0aC4uLlxyXG5cdFx0aWYgKFxyXG5cdFx0XHR0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3MgJiZcclxuXHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoICE9PSB0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3NcclxuXHRcdCkge1xyXG5cdFx0XHQvLyAuLi51cGRhdGUgcmVjb3JkIGxlbmd0aCBhbmQgcmVkcmF3IHRhYmxlXHJcblx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCA9IHRoaXMuZ3RPcHRpb25zLm51bWJlck9mUm93cztcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyAuLi5leHRlbmQgZ3RPcHRpb25zIGRlZmF1bHQgdmFsdWVzIHdpdGggdmFsdWVzIHBhc3NlZCBpbnRvIGNvbXBvbmVudFxyXG5cdFx0dGhpcy5fZ3RPcHRpb25zID0gPEd0T3B0aW9ucz50aGlzLmV4dGVuZChcclxuXHRcdFx0dGhpcy5ndERlZmF1bHRPcHRpb25zLFxyXG5cdFx0XHR0aGlzLl9ndE9wdGlvbnNcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRASW5wdXQoKVxyXG5cdHNldCBndFRvdGFscyh2YWx1ZTogYW55KSB7XHJcblx0XHR0aGlzLl9ndFRvdGFscyA9IHZhbHVlO1xyXG5cdH1cclxuXHRASW5wdXQoKVxyXG5cdHNldCBndEZpZWxkcyh2YWx1ZTogR3RDb25maWdGaWVsZDxSLCBhbnk+W10pIHtcclxuXHRcdHRoaXMuX2d0RmllbGRzID0gdmFsdWU7XHJcblx0XHRjb25zdCBDT0xVTU5TX1dJVEhfQ0xBU1NfTkFNRVMgPSB0aGlzLl9ndEZpZWxkc1xyXG5cdFx0XHQubWFwKGNvbHVtbiA9PiBjb2x1bW4pXHJcblx0XHRcdC5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5jbGFzc05hbWVzKTtcclxuXHRcdC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIHdhcm5pbmcgd2hlbiBzZXR0aW5nIGhhcyBiZWVuIHJlbW92ZWRcclxuXHRcdGlmIChDT0xVTU5TX1dJVEhfQ0xBU1NfTkFNRVMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXHJcblx0XHRcdFx0J0ZpZWxkIHNldHRpbmcgXCJjbGFzc05hbWVzXCIgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3IgZm9yIFwiY29sdW1uQ2xhc3NcIiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUsIHBsZWFzZSB1cGRhdGUgZmllbGQgc2V0dGluZ3MgZm9yIGNvbHVtbiB3aXRoIG9iamVjdCBrZXk6ICcgK1xyXG5cdFx0XHRcdFx0Q09MVU1OU19XSVRIX0NMQVNTX05BTUVTWzBdLm9iamVjdEtleVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRASW5wdXQoKVxyXG5cdHNldCBndFNldHRpbmdzKHZhbHVlOiBHdENvbmZpZ1NldHRpbmdbXSkge1xyXG5cdFx0dGhpcy5fZ3RTZXR0aW5ncyA9IHZhbHVlO1xyXG5cclxuXHRcdC8vIGxvb3AgdGhyb3VnaCBjdXJyZW50IHNldHRpbmdzXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Ly8gc2V0IHNvcnQgZW5hYmxlZC9kaXNhYmxlZCBzZXR0aW5nXHJcblx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydEVuYWJsZWQgPVxyXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydEVuYWJsZWQgIT09IGZhbHNlXHJcblx0XHRcdFx0XHQ/ICh0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnRFbmFibGVkID0gIShcclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgJiZcclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQuaW5kZXhPZignZGlzYWJsZScpICE9PSAtMVxyXG5cdFx0XHRcdFx0ICApKVxyXG5cdFx0XHRcdFx0OiBmYWxzZTtcclxuXHJcblx0XHRcdC8vIGNoZWNrIGlmIHNvcnRpbmcgaXMgdW5kZWZpbmVkLi4uXHJcblx0XHRcdGlmICh0eXBlb2YgdGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdC8vIC4uLmlzIHNvLCBzZXQgc29ydGluZyBwcm9wZXJ0eSB0byBlbmFibGVcclxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPSAnZW5hYmxlJztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY2hlY2sgaWYgY29sdW1uIG9yZGVyIGlzIHVuZGVmaW5lZC4uLlxyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0dHlwZW9mIHRoaXMuX2d0U2V0dGluZ3NbaV0uY29sdW1uT3JkZXIgPT09ICd1bmRlZmluZWQnICYmXHJcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5lbmFibGVkICE9PSBmYWxzZVxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHQvLyAuLi5pcyBzbywgc2V0IHNvcnRpbmcgcHJvcGVydHkgdG8gZW5hYmxlXHJcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5jb2x1bW5PcmRlciA9IHRoaXMuX2d0U2V0dGluZ3NbaSAtIDFdXHJcblx0XHRcdFx0XHQ/IHRoaXMuX2d0U2V0dGluZ3NbaSAtIDFdLmNvbHVtbk9yZGVyICsgMVxyXG5cdFx0XHRcdFx0OiAwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjaGVjayBpZiBjb2x1bW4gbG9jayBzZXR0aW5ncyBhcmUgdW5kZWZpbmVkLi4uXHJcblx0XHRcdGlmICh0eXBlb2YgdGhpcy5fZ3RTZXR0aW5nc1tpXS5sb2NrU2V0dGluZ3MgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0Ly8gLi4uaWYgc28sIHNldCBsb2NrIHNldHRpbmdzIHRvIGZhbHNlIHVubGVzcyBmaWVsZCBpcyBkaXNhYmxlZCAoZW5hYmxlID09PSBmYWxzZSlcclxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLmxvY2tTZXR0aW5ncyA9XHJcblx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLmVuYWJsZWQgPT09IGZhbHNlIHx8IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLnJlc3RydWN0dXJlU29ydGluZygpO1xyXG5cdH1cclxuXHRASW5wdXQoKVxyXG5cdHNldCBndERhdGEoaW5pdGlhbERhdGE6IEFycmF5PGFueT4pIHtcclxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLl9ndE9wdGlvbnMubXV0YXRlRGF0YVxyXG5cdFx0XHQ/IFsuLi5pbml0aWFsRGF0YV1cclxuXHRcdFx0OiB0aGlzLmNsb25lRGVlcChpbml0aWFsRGF0YSk7XHJcblx0XHRpZiAodGhpcy5ndE9wdGlvbnMubGF6eUxvYWQgJiYgdGhpcy5ndEluZm8pIHtcclxuXHRcdFx0dGhpcy5ndE1ldGFQaXBlLnRyYW5zZm9ybShcclxuXHRcdFx0XHRkYXRhLFxyXG5cdFx0XHRcdHRoaXMuZ3RPcHRpb25zLnJvd0luZGV4LFxyXG5cdFx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMSxcclxuXHRcdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcclxuXHRcdFx0KTtcclxuXHRcdFx0aWYgKHRoaXMubGF6eUFsbFNlbGVjdGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgVU5JUVVFX1JPV1MgPSB0aGlzLnNlbGVjdGVkUm93cy5tYXAocm93ID0+IHJvdy4kJGd0Um93SWQpO1xyXG5cdFx0XHRcdGRhdGEubWFwKHJvdyA9PiB7XHJcblx0XHRcdFx0XHRpZiAoVU5JUVVFX1JPV1MuaW5kZXhPZihyb3cuJCRndFJvd0lkKSA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3MucHVzaChyb3cpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMuc2VsZWN0ZWRSb3dzLCAnaXNTZWxlY3RlZCcsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmd0TWV0YVBpcGUudHJhbnNmb3JtKGRhdGEsIHRoaXMuZ3RPcHRpb25zLnJvd0luZGV4KTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLmd0T3B0aW9ucy5yb3dTZWxlY3Rpb25Jbml0aWFsU3RhdGUpIHtcclxuXHRcdFx0ZGF0YS5tYXAocm93ID0+IHtcclxuXHRcdFx0XHRjb25zdCBzZWxlY3RlZCA9XHJcblx0XHRcdFx0XHR0eXBlb2YgdGhpcy5ndE9wdGlvbnMucm93U2VsZWN0aW9uSW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nXHJcblx0XHRcdFx0XHRcdD8gdGhpcy5ndE9wdGlvbnMucm93U2VsZWN0aW9uSW5pdGlhbFN0YXRlKHJvdylcclxuXHRcdFx0XHRcdFx0OiB0aGlzLmd0T3B0aW9ucy5yb3dTZWxlY3Rpb25Jbml0aWFsU3RhdGU7XHJcblx0XHRcdFx0aWYgKHNlbGVjdGVkKSB7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPSB7IGlzU2VsZWN0ZWQ6IHRydWUgfTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0uaXNTZWxlY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cy5wdXNoKHJvdyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGlmIChcclxuXHRcdFx0dGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbFN0YXRlICYmXHJcblx0XHRcdHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxDb21wb25lbnRcclxuXHRcdCkge1xyXG5cdFx0XHRkYXRhLm1hcChyb3cgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGV4cGFuZGVkID1cclxuXHRcdFx0XHRcdHR5cGVvZiB0aGlzLmd0T3B0aW9ucy5yb3dFeHBhbmRJbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbidcclxuXHRcdFx0XHRcdFx0PyB0aGlzLmd0T3B0aW9ucy5yb3dFeHBhbmRJbml0aWFsU3RhdGUocm93KVxyXG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxTdGF0ZTtcclxuXHRcdFx0XHR0aGlzLmV4cGFuZGVkUm93ID0gdGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbENvbXBvbmVudDtcclxuXHJcblx0XHRcdFx0aWYgKGV4cGFuZGVkKSB7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPSB7IGlzT3BlbjogdHJ1ZSB9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXS5pc09wZW4gPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9ndERhdGEgPSBkYXRhO1xyXG5cdH1cclxuXHJcblx0QElucHV0KClcclxuXHRzZXQgZ3RSb3dDb21wb25lbnQodmFsdWU6IFR5cGU8Qz4pIHtcclxuXHRcdGNvbnNvbGUud2FybihcclxuXHRcdFx0J0d0Um93Q29tcG9uZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHN1cHBvcnQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGphbG1lcnMvYW5ndWxhci1nZW5lcmljLXRhYmxlL2lzc3Vlcy8zNCdcclxuXHRcdCk7XHJcblx0XHR0aGlzLl9ndFJvd0NvbXBvbmVudCA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNvbHVtbldpZHRoOiBPYmplY3QgPSB7fTtcclxuXHRwdWJsaWMgY29uZmlnT2JqZWN0OiBHdENvbmZpZzxSPjtcclxuXHRwdWJsaWMgc29ydE9yZGVyOiBBcnJheTxhbnk+ID0gW107XHJcblx0cHVibGljIG1ldGFJbmZvOiB7IFtndFJvd0lkOiBzdHJpbmddOiBHdFJvd01ldGEgfSA9IHt9O1xyXG5cdHB1YmxpYyBzZWxlY3RlZFJvd3M6IEFycmF5PEd0Um93PiA9IFtdO1xyXG5cdHB1YmxpYyBvcGVuUm93czogQXJyYXk8R3RSb3c+ID0gW107XHJcblx0cHJpdmF0ZSBfZ3RTZXR0aW5nczogR3RDb25maWdTZXR0aW5nW10gPSBbXTtcclxuXHRwcml2YXRlIF9ndEZpZWxkczogR3RDb25maWdGaWVsZDxSLCBhbnk+W10gPSBbXTtcclxuXHRwcml2YXRlIF9ndERhdGE6IEFycmF5PGFueT47XHJcblx0cHJpdmF0ZSBfZ3RUb3RhbHM6IGFueTtcclxuXHRwcml2YXRlIF9ndFJvd0NvbXBvbmVudDogVHlwZTxDPjtcclxuXHRwdWJsaWMgZXhwYW5kZWRSb3c6IHtcclxuXHRcdGNvbXBvbmVudDogVHlwZTxDPjtcclxuXHRcdGRhdGE/OiBBcnJheTxhbnk+O1xyXG5cdH07XHJcblx0cHVibGljIGd0RGVmYXVsdFRleHRzOiBHdFRleHRzID0ge1xyXG5cdFx0bG9hZGluZzogJ0xvYWRpbmcuLi4nLFxyXG5cdFx0bm9EYXRhOiAnTm8gZGF0YScsXHJcblx0XHRub01hdGNoaW5nRGF0YTogJ05vIGRhdGEgbWF0Y2hpbmcgcmVzdWx0cyBmb3VuZCcsXHJcblx0XHRub1Zpc2libGVDb2x1bW5zSGVhZGluZzogJ05vIHZpc2libGUgY29sdW1ucycsXHJcblx0XHRub1Zpc2libGVDb2x1bW5zOiAnUGxlYXNlIHNlbGVjdCBhdCBsZWFzdCBvbmUgY29sdW1uIHRvIGJlIHZpc2libGUuJyxcclxuXHRcdHRhYmxlSW5mbzpcclxuXHRcdFx0J1Nob3dpbmcgI3JlY29yZEZyb20gdG8gI3JlY29yZFRvIG9mICNyZWNvcmRzQWZ0ZXJTZWFyY2ggZW50cmllcy4nLFxyXG5cdFx0dGFibGVJbmZvQWZ0ZXJTZWFyY2g6XHJcblx0XHRcdCdTaG93aW5nICAjcmVjb3JkRnJvbSB0byAjcmVjb3JkVG8gb2YgI3JlY29yZHNBZnRlclNlYXJjaCBlbnRyaWVzIChmaWx0ZXJlZCBmcm9tIGEgdG90YWwgb2YgI3JlY29yZHNBbGwgZW50cmllcykuJyxcclxuXHRcdGNzdkRvd25sb2FkOiAnZG93bmxvYWQnLFxyXG5cdFx0c29ydExhYmVsOiAnU29ydDonLFxyXG5cdFx0cGFnaW5hdGVOZXh0OiAnTmV4dCBwYWdlJyxcclxuXHRcdHBhZ2luYXRlUHJldmlvdXM6ICdQcmV2aW91cyBwYWdlJyxcclxuXHRcdGlubGluZUVkaXRFZGl0ZWQ6ICdQcmVzcyBlbnRlciB0byBzYXZlJ1xyXG5cdH07XHJcblx0QElucHV0KCkgZ3RUZXh0czogR3RUZXh0cyA9IHRoaXMuZ3REZWZhdWx0VGV4dHM7XHJcblx0QElucHV0KCkgZ3RDbGFzc2VzOiBzdHJpbmc7XHJcblx0QE91dHB1dCgpIGd0RXZlbnQ6IEV2ZW50RW1pdHRlcjxHdEV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHRwdWJsaWMgZ3REZWZhdWx0T3B0aW9uczogR3RPcHRpb25zID0ge1xyXG5cdFx0Y3N2RGVsaW1pdGVyOiAnOycsXHJcblx0XHRzdGFjazogZmFsc2UsXHJcblx0XHRsYXp5TG9hZDogZmFsc2UsXHJcblx0XHRjYWNoZTogZmFsc2UsXHJcblx0XHRkZWJvdW5jZVRpbWU6IDIwMCxcclxuXHRcdGhpZ2hsaWdodFNlYXJjaDogZmFsc2UsXHJcblx0XHRyb3dTZWxlY3Rpb246IGZhbHNlLFxyXG5cdFx0cm93U2VsZWN0aW9uQWxsb3dNdWx0aXBsZTogdHJ1ZSxcclxuXHRcdHJvd0V4cGFuZEFsbG93TXVsdGlwbGU6IHRydWUsXHJcblx0XHRudW1iZXJPZlJvd3M6IDEwLFxyXG5cdFx0cmVwb3J0Q29sdW1uV2lkdGg6IGZhbHNlLFxyXG5cdFx0YWxsb3dVbnNvcnRlZDogdHJ1ZSxcclxuXHRcdG11dGF0ZURhdGE6IHRydWVcclxuXHR9O1xyXG5cdHByaXZhdGUgX2d0T3B0aW9uczogR3RPcHRpb25zID0gdGhpcy5ndERlZmF1bHRPcHRpb25zO1xyXG5cdHB1YmxpYyBzdG9yZTogQXJyYXk8YW55PiA9IFtdO1xyXG5cdHB1YmxpYyBsb2FkaW5nID0gdHJ1ZTtcclxuXHRwcml2YXRlIGRlYm91bmNlVGltZXI6IHZvaWQgPSBudWxsO1xyXG5cdHB1YmxpYyBsb2FkaW5nUHJvcGVydHk6IHN0cmluZztcclxuXHRwdWJsaWMgbGF6eUFsbFNlbGVjdGVkID0gZmFsc2U7XHJcblxyXG5cdEBJbnB1dCgpXHJcblx0Z3RJbmZvOiBHdEluZm9ybWF0aW9uID0ge1xyXG5cdFx0cGFnZUN1cnJlbnQ6IDEsXHJcblx0XHRwYWdlVG90YWw6IDAsXHJcblx0XHRyZWNvcmRGcm9tOiAwLFxyXG5cdFx0cmVjb3JkVG86IDAsXHJcblx0XHRyZWNvcmRMZW5ndGg6IHRoaXMuZ3RPcHRpb25zLm51bWJlck9mUm93cyxcclxuXHRcdHJlY29yZHNBbGw6IDAsXHJcblx0XHRyZWNvcmRzQWZ0ZXJGaWx0ZXI6IDAsXHJcblx0XHRyZWNvcmRzQWZ0ZXJTZWFyY2g6IDBcclxuXHR9O1xyXG5cclxuXHRwdWJsaWMgcmVmcmVzaFBpcGUgPSBmYWxzZTtcclxuXHRwdWJsaWMgcmVmcmVzaFRvdGFscyA9IGZhbHNlO1xyXG5cdHB1YmxpYyByZWZyZXNoU29ydGluZyA9IGZhbHNlO1xyXG5cdHB1YmxpYyByZWZyZXNoRmlsdGVyID0gZmFsc2U7XHJcblx0cHVibGljIHJlZnJlc2hQYWdlQXJyYXkgPSBmYWxzZTtcclxuXHRwcml2YXRlIGdsb2JhbElubGluZUVkaXRMaXN0ZW5lcjogRnVuY3Rpb247XHJcblx0cHVibGljIGVkaXRlZFJvd3M6IHtcclxuXHRcdFtrZXk6IHN0cmluZ106IHtcclxuXHRcdFx0Y2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBHdFJlbmRlckZpZWxkPEd0Um93LCBhbnk+IH07XHJcblx0XHRcdHJvdzogR3RSb3c7XHJcblx0XHR9O1xyXG5cdH0gPSB7fTtcclxuXHJcblx0cHVibGljIGRhdGE6IHsgZXhwb3J0RGF0YTogQXJyYXk8YW55PiB9ID0geyBleHBvcnREYXRhOiBbXSB9OyAvLyBTdG9yZSBmaWx0ZXJlZCBkYXRhIGZvciBleHBvcnRcclxuXHJcblx0Y29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGd0TWV0YVBpcGU6IEd0TWV0YVBpcGUpIHtcclxuXHRcdHRoaXMuZ3RFdmVudC5zdWJzY3JpYmUoKCRldmVudDogR3RFdmVudCkgPT4ge1xyXG5cdFx0XHRpZiAoJGV2ZW50Lm5hbWUgPT09ICdndC1pbmZvJykge1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoJGV2ZW50Lm5hbWUgPT09ICdndC1yb3ctdXBkYXRlZCcpIHtcclxuXHRcdFx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNvcnQgdGFibGUgYnkgb2JqZWN0IGtleS5cclxuXHQgKiBAcGFyYW0gb2JqZWN0S2V5IC0gbmFtZSBvZiBrZXkgdG8gc29ydCBvbi5cclxuXHQgKiBAcGFyYW0gZXZlbnQgLSBzdWNoIGFzIGtleSBwcmVzcyBkdXJpbmcgc29ydGluZy5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ3RTb3J0ID0gZnVuY3Rpb24ob2JqZWN0S2V5OiBzdHJpbmcsIGV2ZW50OiBhbnkpIHtcclxuXHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbCgpOyAvLyBjYW5jZWwgaW5saW5lIGVkaXRpbmdcclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggY3VycmVudCBzZXR0aW5nc1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSA9PT0gb2JqZWN0S2V5KSB7XHJcblx0XHRcdFx0Ly8gY2hlY2sgaWYgc29ydGluZyBpcyBkaXNhYmxlZC4uLlxyXG5cdFx0XHRcdGlmIChcclxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCAmJlxyXG5cdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0LmluZGV4T2YoJ2Rpc2FibGUnKSAhPT0gLTFcclxuXHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdC8vIC4uLmlmIHNvLCBleGl0IGZ1bmN0aW9uIHdpdGhvdXQgYXBwbHlpbmcgYW55IHNvcnRpbmdcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKFxyXG5cdFx0XHRcdFx0LyogY2hlY2sgaWYgc29ydGluZyBpcyB1bmRlZmluZWQuLi4gKi8gdHlwZW9mIHRoaXMuX2d0U2V0dGluZ3NbaV1cclxuXHRcdFx0XHRcdFx0LnNvcnQgPT09ICd1bmRlZmluZWQnXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHQvLyAuLi5pcyBzbywgc2V0IHNvcnRpbmcgcHJvcGVydHkgdG8gZW5hYmxlXHJcblx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPSAnZW5hYmxlJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjaGVjayBsZW5ndGhcclxuXHRcdGNvbnN0IGN0cmxLZXkgPSBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXk7XHJcblx0XHRjb25zdCBzb3J0ID0gdGhpcy5zb3J0T3JkZXIuc2xpY2UoMCk7XHJcblxyXG5cdFx0bGV0IG1hdGNoID0gLTE7XHJcblx0XHRsZXQgbWF0Y2hEZXNjID0gLTE7XHJcblx0XHRsZXQgcG9zID0gLTE7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgcHJvcGVydHkgYWxyZWFkeSBleGl0c1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IGhpdCA9IHNvcnRbaV0uaW5kZXhPZihvYmplY3RLZXkpO1xyXG5cdFx0XHRpZiAoaGl0ICE9PSAtMSkge1xyXG5cdFx0XHRcdG1hdGNoID0gdGhpcy5zb3J0T3JkZXIuaW5kZXhPZihvYmplY3RLZXkpO1xyXG5cdFx0XHRcdG1hdGNoRGVzYyA9XHJcblx0XHRcdFx0XHRtYXRjaCA9PT0gLTEgPyB0aGlzLnNvcnRPcmRlci5pbmRleE9mKCctJyArIG9iamVjdEtleSkgOiBtYXRjaDtcclxuXHRcdFx0XHRwb3MgPSBNYXRoLm1heChtYXRjaCwgbWF0Y2hEZXNjKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGN0cmwga2V5IG9yIG1ldGEga2V5IGlzIHByZXNzIHRvZ2V0aGVyIHdpdGggc29ydC4uLlxyXG5cdFx0aWYgKGN0cmxLZXkpIHtcclxuXHRcdFx0aWYgKHRoaXMuc29ydE9yZGVyW3RoaXMuc29ydE9yZGVyLmxlbmd0aCAtIDFdID09PSAnJCRndEluaXRpYWxSb3dJbmRleCcpIHtcclxuXHRcdFx0XHR0aGlzLnNvcnRPcmRlci5wb3AoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzd2l0Y2ggKHBvcykge1xyXG5cdFx0XHRcdC8vIC4uLmFuZCBwcm9wZXJ0eSBpcyBub3Qgc29ydGVkIGJlZm9yZS4uLlxyXG5cdFx0XHRcdGNhc2UgLTE6XHJcblx0XHRcdFx0XHQvLyAuLi5hZGQgcHJvcGVydHkgdG8gc29ydGluZ1xyXG5cdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXIucHVzaChvYmplY3RLZXkpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdC8vIC4uLmFuZCBwcm9wZXJ0eSBpcyBzb3J0ZWQgYmVmb3JlLi4uXHJcblx0XHRcdFx0XHRpZiAobWF0Y2ggIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSBmcm9tIGFzYyB0byBkZXNjIGlmIHNvcnRlZCBhc2NcclxuXHRcdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXJbcG9zXSA9ICctJyArIG9iamVjdEtleTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5zb3J0T3JkZXIubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdFx0XHQvLyAuLi5yZW1vdmUgc29ydGluZyBpZiBzb3J0ZWQgZGVzY1xyXG5cdFx0XHRcdFx0XHRpZiAoY3RybEtleSkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyW3Bvc10gPSBvYmplY3RLZXk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXIuc3BsaWNlKHBvcywgMSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5zb3J0T3JkZXIubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdFx0XHRcdC8vIC4uLnNldCBzb3J0aW5nIHRvIGFzYyBpZiBvbmx5IHNvcnRlZCBwcm9wZXJ0eVxyXG5cdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlcltwb3NdID0gb2JqZWN0S2V5O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8qIGlmIGN0cmwga2V5IG9yIG1ldGEga2V5IGlzIG5vdCBwcmVzcyB0b2dldGhlciB3aXRoIHNvcnQuLi4gKi9cclxuXHRcdFx0c3dpdGNoIChwb3MpIHtcclxuXHRcdFx0XHQvLyAuLi5hbmQgcHJvcGVydHkgaXMgbm90IHNvcnRlZCBiZWZvcmUuLi5cclxuXHRcdFx0XHRjYXNlIC0xOlxyXG5cdFx0XHRcdFx0Ly8gLi4uc29ydCBieSBwcm9wZXJ0eVxyXG5cdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXIgPSBbb2JqZWN0S2V5XTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgZnJvbSBkZXNjIHRvIGFzYyBhbmQgdmlzZSB2ZXJzYVxyXG5cdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXIgPVxyXG5cdFx0XHRcdFx0XHRtYXRjaCAhPT0gLTFcclxuXHRcdFx0XHRcdFx0XHQ/IFsnLScgKyBvYmplY3RLZXldXHJcblx0XHRcdFx0XHRcdFx0OiBjdHJsS2V5IHx8ICF0aGlzLmd0T3B0aW9ucy5hbGxvd1Vuc29ydGVkXHJcblx0XHRcdFx0XHRcdFx0XHQ/IFtvYmplY3RLZXldXHJcblx0XHRcdFx0XHRcdFx0XHQ6IFtdO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgc2V0dGluZ3Mgb2JqZWN0IHdpdGggbmV3IHNvcnRpbmcgaW5mb3JtYXRpb25cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXkgPT09IG9iamVjdEtleSkge1xyXG5cdFx0XHRcdHN3aXRjaCAodGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0KSB7XHJcblx0XHRcdFx0XHQvLyBpZiBzb3J0ZWQgYXNjLi4uXHJcblx0XHRcdFx0XHRjYXNlICdhc2MnOlxyXG5cdFx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgdG8gZGVzY1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPSAnZGVzYyc7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Ly8gaWYgc29ydGVkIGRlc2MuLi5cclxuXHRcdFx0XHRcdGNhc2UgJ2Rlc2MnOlxyXG5cdFx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgdG8gYXNjIGlmIGl0J3MgdGhlIG9ubHkgc29ydGVkIHByb3BlcnR5IG90aGVyd2lzZSByZW1vdmUgc29ydGluZ1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPVxyXG5cdFx0XHRcdFx0XHRcdCh0aGlzLnNvcnRPcmRlci5sZW5ndGggPT09IDEgJiYgc29ydC5sZW5ndGggPCAyKSB8fFxyXG5cdFx0XHRcdFx0XHRcdGN0cmxLZXkgfHxcclxuXHRcdFx0XHRcdFx0XHQhdGhpcy5ndE9wdGlvbnMuYWxsb3dVbnNvcnRlZFxyXG5cdFx0XHRcdFx0XHRcdFx0PyAnYXNjJ1xyXG5cdFx0XHRcdFx0XHRcdFx0OiAnZW5hYmxlJztcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHQvLyBpZiBzb3J0aW5nIGVuYWJsZWQuLi5cclxuXHRcdFx0XHRcdGNhc2UgJ2VuYWJsZSc6XHJcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSB0byBhc2NcclxuXHRcdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2FzYyc7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnRPcmRlciA9XHJcblx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPT09ICdlbmFibGUnXHJcblx0XHRcdFx0XHRcdD8gdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxXHJcblx0XHRcdFx0XHRcdDogdGhpcy5zb3J0T3JkZXIuaW5kZXhPZihvYmplY3RLZXkpID09PSAtMVxyXG5cdFx0XHRcdFx0XHRcdD8gdGhpcy5zb3J0T3JkZXIuaW5kZXhPZignLScgKyBvYmplY3RLZXkpXHJcblx0XHRcdFx0XHRcdFx0OiB0aGlzLnNvcnRPcmRlci5pbmRleE9mKG9iamVjdEtleSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ICYmXHJcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0LmluZGV4T2YoJ2Rpc2FibGUnKSA9PT0gLTEgJiZcclxuXHRcdFx0XHR0aGlzLnNvcnRPcmRlci5pbmRleE9mKHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5KSA9PT0gLTEgJiZcclxuXHRcdFx0XHR0aGlzLnNvcnRPcmRlci5pbmRleE9mKCctJyArIHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5KSA9PT0gLTFcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2VuYWJsZSc7XHJcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0T3JkZXIgPSB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aCAtIDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZWZyZXNoIHNvcnRpbmcgcGlwZVxyXG5cdFx0dGhpcy5yZWZyZXNoU29ydGluZyA9ICF0aGlzLnJlZnJlc2hTb3J0aW5nO1xyXG5cdFx0dGhpcy5yZWZyZXNoUGFnZUFycmF5ID0gIXRoaXMucmVmcmVzaFBhZ2VBcnJheTtcclxuXHJcblx0XHQvLyBzb3J0IGJ5IGluaXRpYWwgc29ydCBvcmRlciBhcyBsYXN0IHJlc29ydFxyXG5cdFx0dGhpcy5zb3J0T3JkZXIucHVzaCgnJCRndEluaXRpYWxSb3dJbmRleCcpO1xyXG5cclxuXHRcdC8vIGVtaXQgc29ydCBldmVudFxyXG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xyXG5cdFx0XHRuYW1lOiAnZ3Qtc29ydGluZy1hcHBsaWVkJyxcclxuXHRcdFx0dmFsdWU6IHRoaXMuc29ydE9yZGVyXHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDaGFuZ2UgbnVtYmVyIG9mIHJvd3MgdG8gYmUgZGlzcGxheWVkLlxyXG5cdCAqIEBwYXJhbSByb3dMZW5ndGggLSB0b3RhbCBudW1iZXIgb2Ygcm93cy5cclxuXHQgKiBAcGFyYW0gcmVzZXQgLSBzaG91bGQgcGFnZSBiZSByZXNldCB0byBmaXJzdCBwYWdlLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjaGFuZ2VSb3dMZW5ndGggPSBmdW5jdGlvbihyb3dMZW5ndGg6IGFueSwgcmVzZXQ/OiBib29sZWFuKSB7XHJcblx0XHRsZXQgbGVuZ3RoVmFsdWUgPSBpc05hTihwYXJzZUludChyb3dMZW5ndGgsIDEwKSlcclxuXHRcdFx0PyAwXHJcblx0XHRcdDogcGFyc2VJbnQocm93TGVuZ3RoLCAxMCk7XHJcblx0XHRsZXQgbmV3UG9zaXRpb24gPSAxO1xyXG5cclxuXHRcdGlmICghbGVuZ3RoVmFsdWUgJiYgdGhpcy5ndERhdGEpIHtcclxuXHRcdFx0bGVuZ3RoVmFsdWUgPSB0aGlzLmd0RGF0YS5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgcmVzZXQgaXMgbm90IHRydWUgYW5kIHdlJ3JlIG5vdCBsYXp5IGxvYWRpbmcgZGF0YS4uLlxyXG5cdFx0aWYgKHJlc2V0ICE9PSB0cnVlICYmIHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCAhPT0gdHJ1ZSkge1xyXG5cdFx0XHQvLyAuLi5nZXQgY3VycmVudCBwb3NpdGlvbiBpbiByZWNvcmQgc2V0XHJcblx0XHRcdGNvbnN0IGN1cnJlbnRSZWNvcmQgPVxyXG5cdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCAqICh0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDEpO1xyXG5cdFx0XHRjb25zdCBjdXJyZW50UG9zaXRpb24gPVxyXG5cdFx0XHRcdHRoaXMuX2d0RGF0YS5pbmRleE9mKHRoaXMuX2d0RGF0YVtjdXJyZW50UmVjb3JkXSkgKyAxO1xyXG5cclxuXHRcdFx0Ly8gLi4uZ2V0IG5ldyBwb3NpdGlvblxyXG5cdFx0XHRuZXdQb3NpdGlvbiA9IE1hdGguY2VpbChjdXJyZW50UG9zaXRpb24gLyBsZW5ndGhWYWx1ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2hhbmdlIHJvdyBsZW5ndGhcclxuXHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCA9IGxlbmd0aFZhbHVlO1xyXG5cclxuXHRcdC8vIGdvIHRvIG5ldyBwb3NpdGlvblxyXG5cdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgPSBuZXdQb3NpdGlvbjtcclxuXHJcblx0XHQvLyBpZiBsYXp5IGxvYWRpbmcgZGF0YS4uLlxyXG5cdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCkge1xyXG5cdFx0XHQvLyAuLi5yZXBsYWNlIGRhdGEgd2l0aCBwbGFjZSBob2xkZXJzIGZvciBuZXcgZGF0YVxyXG5cdFx0XHR0aGlzLl9ndERhdGFbMF0gPSB0aGlzLmxvYWRpbmdDb250ZW50KGxlbmd0aFZhbHVlKTtcclxuXHJcblx0XHRcdC8vIC4uLmVtcHR5IGN1cnJlbnQgc3RvcmVcclxuXHRcdFx0dGhpcy5zdG9yZSA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcclxuXHJcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XHJcblx0XHRcdG5hbWU6ICdndC1yb3ctbGVuZ3RoLWNoYW5nZWQnLFxyXG5cdFx0XHR2YWx1ZTogbGVuZ3RoVmFsdWVcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvcmNlIGEgcmVkcmF3IG9mIHRhYmxlIHJvd3MuXHJcblx0ICogQXMgdGhlIHRhYmxlIHVzZXMgcHVyZSBwaXBlcywgd2UgbmVlZCB0byBmb3JjZSBhIHJlZHJhdyBpZiBhbiBvYmplY3QgaW4gdGhlIGFycmF5IGlzIGNoYW5nZWQgdG8gc2VlIHRoZSBjaGFuZ2VzLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZWRyYXcgPSBmdW5jdGlvbigkZXZlbnQ/OiBhbnkpIHtcclxuXHRcdHRoaXMucmVmcmVzaFNvcnRpbmcgPSAhdGhpcy5yZWZyZXNoU29ydGluZztcclxuXHRcdHRoaXMucmVmcmVzaFBhZ2VBcnJheSA9ICF0aGlzLnJlZnJlc2hQYWdlQXJyYXk7XHJcblx0XHR0aGlzLnJlZnJlc2hQaXBlID0gIXRoaXMucmVmcmVzaFBpcGU7XHJcblx0fTtcclxuXHJcblx0LyoqIFVwZGF0ZSByZWNvcmQgcmFuZ2UuICovXHJcblx0cHJpdmF0ZSB1cGRhdGVSZWNvcmRSYW5nZSgpIHtcclxuXHRcdHRoaXMuZ3RJbmZvLnJlY29yZEZyb20gPVxyXG5cdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRzQWZ0ZXJTZWFyY2ggPT09IDBcclxuXHRcdFx0XHQ/IDBcclxuXHRcdFx0XHQ6ICh0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDEpICogdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoICsgMTtcclxuXHRcdHRoaXMuZ3RJbmZvLnJlY29yZFRvID1cclxuXHRcdFx0dGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoIDxcclxuXHRcdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgKiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcclxuXHRcdFx0XHQ/IHRoaXMuZ3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaFxyXG5cdFx0XHRcdDogdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgKiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGg7XHJcblx0fVxyXG5cclxuXHQvKiogVXBkYXRlIHRvdGFscy4gKi9cclxuXHRwcml2YXRlIHVwZGF0ZVRvdGFscygpIHtcclxuXHRcdHRoaXMucmVmcmVzaFRvdGFscyA9ICF0aGlzLnJlZnJlc2hUb3RhbHM7XHJcblx0fVxyXG5cclxuXHQvKiogR28gdG8gbmV4dCBwYWdlLiAqL1xyXG5cdHB1YmxpYyBuZXh0UGFnZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0Y29uc3QgcGFnZSA9XHJcblx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ID09PSB0aGlzLmd0SW5mby5wYWdlVG90YWxcclxuXHRcdFx0XHQ/IHRoaXMuZ3RJbmZvLnBhZ2VUb3RhbFxyXG5cdFx0XHRcdDogdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgKyAxO1xyXG5cdFx0dGhpcy5nb1RvUGFnZShwYWdlKTtcclxuXHR9O1xyXG5cclxuXHQvKiogR28gdG8gcHJldmlvdXMgcGFnZS4gKi9cclxuXHRwdWJsaWMgcHJldmlvdXNQYWdlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRjb25zdCBwYWdlID1cclxuXHRcdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgPT09IDEgPyAxIDogdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxO1xyXG5cdFx0dGhpcy5nb1RvUGFnZShwYWdlKTtcclxuXHR9O1xyXG5cclxuXHQvKiogUmVxdWVzdCBtb3JlIGRhdGEgKHVzZWQgd2hlbiBsYXp5IGxvYWRpbmcpICovXHJcblx0cHJpdmF0ZSBnZXREYXRhID0gZnVuY3Rpb24oKSB7XHJcblx0XHQvLyAuLi5lbWl0IGV2ZW50IHJlcXVlc3RpbmcgZm9yIG1vcmUgZGF0YVxyXG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xyXG5cdFx0XHRuYW1lOiAnZ3QtcGFnZS1jaGFuZ2VkLWxhenknLFxyXG5cdFx0XHR2YWx1ZToge1xyXG5cdFx0XHRcdHBhZ2VDdXJyZW50OiB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCxcclxuXHRcdFx0XHRyZWNvcmRMZW5ndGg6IHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBHbyB0byBzcGVjaWZpYyBwYWdlLlxyXG5cdCAqIEBwYXJhbSBwYWdlIC0gcGFnZSBudW1iZXIuXHJcblx0ICovXHJcblx0cHVibGljIGdvVG9QYWdlID0gZnVuY3Rpb24ocGFnZTogbnVtYmVyKSB7XHJcblx0XHRjb25zdCBwcmV2aW91c1BhZ2UgPSB0aGlzLmd0SW5mby5wYWdlQ3VycmVudDtcclxuXHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ID0gcGFnZTtcclxuXHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbCgpOyAvLyBjYW5jZWwgaW5saW5lIGVkaXRcclxuXHJcblx0XHQvLyBpZiBsYXp5IGxvYWRpbmcgYW5kIGlmIHBhZ2UgY29udGFpbnMgbm8gcmVjb3Jkcy4uLlxyXG5cdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCkge1xyXG5cdFx0XHQvLyAuLi5pZiBkYXRhIGZvciBjdXJyZW50IHBhZ2UgY29udGFpbnMgbm8gZW50cmllcy4uLlxyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0dGhpcy5fZ3RPcHRpb25zLmNhY2hlID09PSBmYWxzZSB8fFxyXG5cdFx0XHRcdHRoaXMuX2d0RGF0YVt0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDFdLmxlbmd0aCA9PT0gMFxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHQvLyAuLi5jcmVhdGUgdGVtcG9yYXJ5IGNvbnRlbnQgd2hpbGUgd2FpdGluZyBmb3IgZGF0YVxyXG5cdFx0XHRcdHRoaXMuX2d0RGF0YVt0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDFdID0gdGhpcy5sb2FkaW5nQ29udGVudChcclxuXHRcdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dGhpcy5sb2FkaW5nID0gdHJ1ZTsgLy8gbG9hZGluZyB0cnVlXHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gLi4uaWYgZmlyc3QgZW50cnkgaW4gY3VycmVudCBwYWdlIGVxdWFscyBvdXIgbG9hZGluZyBwbGFjZWhvbGRlci4uLlxyXG5cdFx0XHRpZiAoXHJcblx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV1bMF1bdGhpcy5sb2FkaW5nUHJvcGVydHldID09PVxyXG5cdFx0XHRcdHRoaXMuZ3RUZXh0cy5sb2FkaW5nXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdC8vIC4uLmdldCBkYXRhXHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5kZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLmdldERhdGEoKTtcclxuXHRcdFx0XHR9LCB0aGlzLl9ndE9wdGlvbnMuZGVib3VuY2VUaW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcclxuXHJcblx0XHQvLyAuLi5lbWl0IHBhZ2UgY2hhbmdlIGV2ZW50XHJcblx0XHRpZiAocHJldmlvdXNQYWdlICE9PSBwYWdlKSB7XHJcblx0XHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcclxuXHRcdFx0XHRuYW1lOiAnZ3QtcGFnZS1jaGFuZ2VkJyxcclxuXHRcdFx0XHR2YWx1ZToge1xyXG5cdFx0XHRcdFx0cGFnZUN1cnJlbnQ6IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50LFxyXG5cdFx0XHRcdFx0cGFnZVByZXZpb3VzOiBwcmV2aW91c1BhZ2UsXHJcblx0XHRcdFx0XHRyZWNvcmRMZW5ndGg6IHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IG1ldGEgZGF0YSBmb3Igcm93LlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZXRSb3dTdGF0ZShyb3c6IFIpOiBHdFJvd01ldGEge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID09PSAndW5kZWZpbmVkJ1xyXG5cdFx0XHQ/IG51bGxcclxuXHRcdFx0OiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhwYW5kIGFsbCByb3dzLlxyXG5cdCAqIEBwYXJhbSBleHBhbmRlZFJvdyAtIGNvbXBvbmVudCB0byByZW5kZXIgd2hlbiByb3dzIGFyZSBleHBhbmRlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZXhwYW5kQWxsUm93cyhleHBhbmRlZFJvdzogeyBjb21wb25lbnQ6IFR5cGU8Qz47IGRhdGE/OiBhbnkgfSk6IHZvaWQge1xyXG5cdFx0dGhpcy5leHBhbmRlZFJvdyA9IGV4cGFuZGVkUm93O1xyXG5cdFx0dGhpcy5fdG9nZ2xlQWxsUm93UHJvcGVydHkoJ2lzT3BlbicsIHRydWUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29sbGFwc2UgYWxsIHJvd3MuXHJcblx0ICovXHJcblx0cHVibGljIGNvbGxhcHNlQWxsUm93cygpOiB2b2lkIHtcclxuXHRcdHRoaXMuX3RvZ2dsZUFsbFJvd1Byb3BlcnR5KCdpc09wZW4nLCBmYWxzZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZWxlY3QgYWxsIHJvd3MuXHJcblx0ICovXHJcblx0cHVibGljIHNlbGVjdEFsbFJvd3MoKTogdm9pZCB7XHJcblx0XHR0aGlzLl90b2dnbGVBbGxSb3dQcm9wZXJ0eSgnaXNTZWxlY3RlZCcsIHRydWUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVzZWxlY3QgYWxsIHJvd3MuXHJcblx0ICovXHJcblx0cHVibGljIGRlc2VsZWN0QWxsUm93cygpOiB2b2lkIHtcclxuXHRcdHRoaXMuX3RvZ2dsZUFsbFJvd1Byb3BlcnR5KCdpc1NlbGVjdGVkJywgZmFsc2UpO1xyXG5cdH1cclxuXHQvKipcclxuXHQgKiBUb2dnbGUgYWxsIHJvd3MuXHJcblx0ICovXHJcblx0cHVibGljIHRvZ2dsZUFsbFJvd3MoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLmxhenlMb2FkKSB7XHJcblx0XHRcdGlmICghdGhpcy5sYXp5QWxsU2VsZWN0ZWQgfHwgdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0dGhpcy5zZWxlY3RBbGxSb3dzKCk7XHJcblx0XHRcdFx0dGhpcy5sYXp5QWxsU2VsZWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZGVzZWxlY3RBbGxSb3dzKCk7XHJcblx0XHRcdFx0dGhpcy5sYXp5QWxsU2VsZWN0ZWQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMuc2VsZWN0ZWRSb3dzLmxlbmd0aCAhPT0gdGhpcy5ndERhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhpcy5zZWxlY3RBbGxSb3dzKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5kZXNlbGVjdEFsbFJvd3MoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlIHJvdyBjb2xsYXBzZWQgc3RhdGUgaWUuIGV4cGFuZGVkL29wZW4gb3IgY29sbGFwc2VkL2Nsb3NlZC5cclxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdCB0aGF0IHNob3VsZCBiZSBleHBhbmRlZC9jb2xsYXBzZWQuXHJcblx0ICogQHBhcmFtIGV4cGFuZGVkUm93IC0gY29tcG9uZW50IHRvIHJlbmRlciB3aGVuIHJvdyBpcyBleHBhbmRlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgdG9nZ2xlQ29sbGFwc2UoXHJcblx0XHRyb3c6IEd0Um93LFxyXG5cdFx0ZXhwYW5kZWRSb3c/OiB7IGNvbXBvbmVudDogVHlwZTxDPjsgZGF0YT86IGFueSB9XHJcblx0KSB7XHJcblx0XHRpZiAoZXhwYW5kZWRSb3cpIHtcclxuXHRcdFx0dGhpcy5leHBhbmRlZFJvdyA9IGV4cGFuZGVkUm93O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fdG9nZ2xlUm93UHJvcGVydHkocm93LCAnaXNPcGVuJyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGUgcm93IHNlbGVjdGVkIHN0YXRlIGllLiBzZWxlY3RlZCBvciBub3QuXHJcblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQvZGVzZWxlY3RlZC5cclxuXHQgKi9cclxuXHRwdWJsaWMgdG9nZ2xlU2VsZWN0KHJvdzogR3RSb3cpIHtcclxuXHRcdHRoaXMuX3RvZ2dsZVJvd1Byb3BlcnR5KHJvdywgJ2lzU2VsZWN0ZWQnKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByb3dDbGljayhyb3c6IEd0Um93LCAkZXZlbnQ6IE1vdXNlRXZlbnQpIHtcclxuXHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcclxuXHRcdFx0bmFtZTogJ2d0LXJvdy1jbGlja2VkJyxcclxuXHRcdFx0dmFsdWU6IHsgcm93OiByb3csIGV2ZW50OiAkZXZlbnQgfVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgcm93IGRhdGEuXHJcblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QgdGhhdCBoYXMgYmVlbiBlZGl0ZWQuXHJcblx0ICogQHBhcmFtIG9sZFZhbHVlIC0gcm93IG9iamVjdCBiZWZvcmUgZWRpdC5cclxuXHQgKi9cclxuXHRwdWJsaWMgdXBkYXRlUm93KHJvdzogR3RSb3csIG9sZFZhbHVlOiBHdFJvdykge1xyXG5cdFx0dGhpcy5fdG9nZ2xlUm93UHJvcGVydHkocm93LCAnaXNVcGRhdGVkJywgb2xkVmFsdWUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogcmVtb3ZlcyBhIHJvdyBmcm9tIHRoZSB0YWJsZVxyXG5cdCAqIEBwYXJhbSByb3cgLSB0aGUgcm93IG9iamVjdCB0byByZW1vdmVcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVtb3ZlUm93KHJvdzogR3RSb3cpIHtcclxuXHRcdGlmICh0aGlzLmlzUm93U2VsZWN0ZWQocm93KSkge1xyXG5cdFx0XHR0aGlzLnRvZ2dsZVNlbGVjdChyb3cpO1xyXG5cdFx0fVxyXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLl9ndERhdGEuaW5kZXhPZihyb3cpO1xyXG5cdFx0dGhpcy5fZ3REYXRhLnNwbGljZShpbmRleCwgMSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBjaGVjayBpZiBhIHJvdyBpcyBzZWxlY3RlZFxyXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0XHJcblx0ICovXHJcblx0cHVibGljIGlzUm93U2VsZWN0ZWQocm93OiBHdFJvdyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSAmJiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdLmlzU2VsZWN0ZWRcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbWV0YSBpbmZvIGZvciBhbGwgcm93cywgaWUuIGlzU2VsZWN0ZWQsIGlzT3Blbi5cclxuXHQgKiBAcGFyYW0gYXJyYXkgLSBhcnJheSB0aGF0IGhvbGRzIHJvd3MgdGhhdCBuZWVkIHRvIGJlIHVwZGF0ZWQuXHJcblx0ICogQHBhcmFtIHByb3BlcnR5IC0gbmFtZSBvZiBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBjaGFuZ2VkL3RvZ2dsZWQuXHJcblx0ICogQHBhcmFtIGFjdGl2ZSAtIHNob3VsZCByb3dzIGJlIGV4cGFuZGVkL29wZW4sIHNlbGVjdGVkLlxyXG5cdCAqIEBwYXJhbSBleGNlcHRpb24gLSB1cGRhdGUgYWxsIHJvd3MgZXhjZXB0IHRoaXMgb25lLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX3VwZGF0ZU1ldGFJbmZvKFxyXG5cdFx0YXJyYXk6IEFycmF5PEd0Um93PixcclxuXHRcdHByb3BlcnR5OiBzdHJpbmcsXHJcblx0XHRhY3RpdmU6IGJvb2xlYW4sXHJcblx0XHRleGNlcHRpb24/OiBHdFJvd1xyXG5cdCkge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMubWV0YUluZm9bYXJyYXlbaV0uJCRndFJvd0lkXSkge1xyXG5cdFx0XHRcdHRoaXMubWV0YUluZm9bYXJyYXlbaV0uJCRndFJvd0lkXSA9IHt9O1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChleGNlcHRpb24gJiYgYXJyYXlbaV0uJCRndFJvd0lkID09PSBleGNlcHRpb24uJCRndFJvd0lkKSB7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5tZXRhSW5mb1thcnJheVtpXS4kJGd0Um93SWRdW3Byb3BlcnR5XSA9IGFjdGl2ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUHVzaCBzZWxlY3RlZC9leHBhbmRlZCBsYXp5IGxvYWRlZCByb3dzIHRvIGFycmF5IHdpdGggbWV0YSBkYXRhLlxyXG5cdCAqIEBwYXJhbSB0YXJnZXQgLSBhcnJheSB0byB3aGljaCByb3dzIHNob3VsZCBiZSBhZGRlZC5cclxuXHQgKiBAcGFyYW0gc291cmNlIC0gYXJyYXkgdGhhdCBob2xkcyByb3dzIHRoYXQgc2hvdWxkIGJlIGFkZGVkLlxyXG5cdCAqIEByZXR1cm5zIGFycmF5IHdpdGggYWRkZWQgcm93cy5cclxuXHQgKi9cclxuXHRwcml2YXRlIF9wdXNoTGF6eVJvd3MoXHJcblx0XHR0YXJnZXQ6IEFycmF5PEd0Um93PixcclxuXHRcdHNvdXJjZTogQXJyYXk8R3RSb3c+XHJcblx0KTogQXJyYXk8R3RSb3c+IHtcclxuXHRcdGNvbnN0IFVOSVFVRV9ST1dTID0gdGFyZ2V0Lm1hcChyb3cgPT4gcm93LiQkZ3RSb3dJZCk7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHQvLyBvbmx5IGFkZCBpZiBub3QgYWxyZWFkeSBpbiBsaXN0XHJcblx0XHRcdGlmIChVTklRVUVfUk9XUy5pbmRleE9mKHNvdXJjZVtpXS4kJGd0Um93SWQpID09PSAtMSkge1xyXG5cdFx0XHRcdHRhcmdldC5wdXNoKHNvdXJjZVtpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGUgbWV0YSBpbmZvIGZvciBhbGwgcm93cywgaWUuIGlzU2VsZWN0ZWQsIGlzT3Blbi5cclxuXHQgKiBAcGFyYW0gcHJvcGVydHkgLSBuYW1lIG9mIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIGNoYW5nZWQvdG9nZ2xlZC5cclxuXHQgKiBAcGFyYW0gYWN0aXZlIC0gc2hvdWxkIHJvd3MgYmUgZXhwYW5kZWQvb3Blbiwgc2VsZWN0ZWQuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfdG9nZ2xlQWxsUm93UHJvcGVydHkocHJvcGVydHk6IHN0cmluZywgYWN0aXZlOiBib29sZWFuKSB7XHJcblx0XHRsZXQgZXZlbnROYW1lOiBzdHJpbmc7XHJcblx0XHRsZXQgZXZlbnRWYWx1ZTogYW55O1xyXG5cdFx0c3dpdGNoIChwcm9wZXJ0eSkge1xyXG5cdFx0XHRjYXNlICdpc09wZW4nOlxyXG5cdFx0XHRcdC8vIGNoZWNrIGlmIG11bHRpcGxlIGV4cGFuZGVkIHJvd3MgYXJlIGFsbG93ZWQuLi5cclxuXHRcdFx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLnJvd0V4cGFuZEFsbG93TXVsdGlwbGUgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIGV4aXQgZnVuY3Rpb25cclxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFxyXG5cdFx0XHRcdFx0XHQnZmVhdHVyZSBkaXNhYmxlZDogZW5hYmxlIGJ5IHNldHRpbmcgXCJyb3dFeHBhbmRBbGxvd011bHRpcGxlID0gdHJ1ZVwiJ1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGFjdGl2ZSkge1xyXG5cdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2V4cGFuZC1hbGwnO1xyXG5cdFx0XHRcdFx0dGhpcy5vcGVuUm93cyA9IHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZFxyXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX3B1c2hMYXp5Um93cyhcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMub3BlblJvd3MsXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9ndERhdGFbdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxXS5zbGljZSgpXHJcblx0XHRcdFx0XHRcdCAgKVxyXG5cdFx0XHRcdFx0XHQ6IHRoaXMuX2d0RGF0YS5zbGljZSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5vcGVuUm93cywgcHJvcGVydHksIGFjdGl2ZSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdjb2xsYXBzZS1hbGwnO1xyXG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5vcGVuUm93cywgcHJvcGVydHksIGFjdGl2ZSk7XHJcblx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzID0gW107XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGV2ZW50VmFsdWUgPSB7XHJcblx0XHRcdFx0XHRleHBhbmRlZFJvd3M6IHRoaXMub3BlblJvd3MsXHJcblx0XHRcdFx0XHRjaGFuZ2VkUm93OiAnYWxsJ1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ2lzU2VsZWN0ZWQnOlxyXG5cdFx0XHRcdC8vIGNoZWNrIGlmIG11bHRpIHJvdyBzZWxlY3Rpb24gaXMgYWxsb3dlZC4uLlxyXG5cdFx0XHRcdGlmICh0aGlzLl9ndE9wdGlvbnMucm93U2VsZWN0aW9uQWxsb3dNdWx0aXBsZSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdC8vIC4uLmlmIG5vdCwgZXhpdCBmdW5jdGlvblxyXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXHJcblx0XHRcdFx0XHRcdCdmZWF0dXJlIGRpc2FibGVkOiBlbmFibGUgYnkgc2V0dGluZyBcInJvd1NlbGVjdGlvbkFsbG93TXVsdGlwbGUgPSB0cnVlXCInXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoYWN0aXZlKSB7XHJcblx0XHRcdFx0XHRldmVudE5hbWUgPSAnc2VsZWN0LWFsbCc7XHJcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cyA9IHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZFxyXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX3B1c2hMYXp5Um93cyhcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLFxyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV0uc2xpY2UoKVxyXG5cdFx0XHRcdFx0XHQgIClcclxuXHRcdFx0XHRcdFx0OiB0aGlzLl9ndERhdGEuc2xpY2UoKTtcclxuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMuc2VsZWN0ZWRSb3dzLCBwcm9wZXJ0eSwgYWN0aXZlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2Rlc2VsZWN0LWFsbCc7XHJcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLnNlbGVjdGVkUm93cywgcHJvcGVydHksIGFjdGl2ZSk7XHJcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cyA9IFtdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRldmVudFZhbHVlID0ge1xyXG5cdFx0XHRcdFx0c2VsZWN0ZWRSb3dzOiB0aGlzLnNlbGVjdGVkUm93cyxcclxuXHRcdFx0XHRcdGNoYW5nZWRSb3c6ICdhbGwnXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XHJcblx0XHRcdG5hbWU6ICdndC1yb3ctJyArIGV2ZW50TmFtZSxcclxuXHRcdFx0dmFsdWU6IGV2ZW50VmFsdWVcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlIG1ldGEgaW5mbyBmb3Igcm93LCBpZS4gaXNTZWxlY3RlZCwgaXNPcGVuLlxyXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSBwcm9wZXJ0eSAtIG5hbWUgb2YgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgY2hhbmdlZC90b2dnbGVkLlxyXG5cdCAqIEBwYXJhbSBwcm9wZXJ0eVZhbHVlcyAtIG9wdGlvbmFsIHByb3BlcnR5IHZhbHVlcyB0aGF0IGNhbiBiZSBwYXNzZWQuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfdG9nZ2xlUm93UHJvcGVydHkoXHJcblx0XHRyb3c6IEd0Um93LFxyXG5cdFx0cHJvcGVydHk6IHN0cmluZyxcclxuXHRcdHByb3BlcnR5VmFsdWVzPzogYW55XHJcblx0KSB7XHJcblx0XHRsZXQgZXZlbnROYW1lOiBzdHJpbmc7XHJcblx0XHRsZXQgZXZlbnRWYWx1ZTogYW55O1xyXG5cdFx0Ly8gbWFrZSBzdXJlIGd0Um93SWQgZXhpc3RzIG9uIHJvdyBvYmplY3RcclxuXHRcdGlmICh0eXBlb2Ygcm93LiQkZ3RSb3dJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0Ly8gY2hlY2sgaWYgbWV0YSBpbmZvIGV4aXN0cyBmb3Igcm93XHJcblx0XHRcdGlmICghdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSkge1xyXG5cdFx0XHRcdC8vIGlmIG5vdCwgYWRkIG9iamVjdCB0byBzdG9yZSBtZXRhIGluZm9cclxuXHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID0ge307XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN3aXRjaCAocHJvcGVydHkpIHtcclxuXHRcdFx0XHRjYXNlICdpc09wZW4nOlxyXG5cdFx0XHRcdFx0Y29uc3Qgb3BlbmVkID0gdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV07XHJcblxyXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgbXVsdGlwbGUgZXhwYW5kZWQgcm93cyBhcmUgYWxsb3dlZC4uLlxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5yb3dFeHBhbmRBbGxvd011bHRpcGxlID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIGNvbGxhcHNlIGFsbCByb3dzIGV4Y2VwdCBjdXJyZW50IHJvd1xyXG5cdFx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLm9wZW5Sb3dzLCBwcm9wZXJ0eSwgZmFsc2UsIHJvdyk7XHJcblx0XHRcdFx0XHRcdHRoaXMub3BlblJvd3MgPSBbXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBjaGVjayBpZiByb3cgaXMgZXhwYW5kZWRcclxuXHRcdFx0XHRcdGlmICghb3BlbmVkKSB7XHJcblx0XHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdleHBhbmQnO1xyXG5cdFx0XHRcdFx0XHQvLyBhZGQgcm93IHRvIGV4cGFuZGVkIHJvd3NcclxuXHRcdFx0XHRcdFx0dGhpcy5vcGVuUm93cy5wdXNoKHJvdyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRldmVudE5hbWUgPSAnY29sbGFwc2UnO1xyXG5cdFx0XHRcdFx0XHQvLyBsb29wIHRocm91Z2ggZXhwYW5kZWQgcm93cy4uLlxyXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3BlblJvd3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBpZiBleHBhbmRlZCByb3cgZXF1YWxzIHBhc3NlZCByb3cuLi5cclxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vcGVuUm93c1tpXS4kJGd0Um93SWQgPT09IHJvdy4kJGd0Um93SWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLnJlbW92ZSByb3cgZnJvbSBleHBhbmRlZCByb3dzLi4uXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZXhpdCBsb29wXHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGV2ZW50VmFsdWUgPSB7XHJcblx0XHRcdFx0XHRcdGV4cGFuZGVkUm93czogdGhpcy5vcGVuUm93cyxcclxuXHRcdFx0XHRcdFx0Y2hhbmdlZFJvdzogcm93XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnaXNTZWxlY3RlZCc6XHJcblx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZCA9IHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldO1xyXG5cclxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIG11bHRpIHJvdyBzZWxlY3Rpb24gaXMgYWxsb3dlZC4uLlxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5yb3dTZWxlY3Rpb25BbGxvd011bHRpcGxlID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIGRlc2VsZWN0IGFsbCByb3dzIGV4Y2VwdCBjdXJyZW50IHJvd1xyXG5cdFx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLnNlbGVjdGVkUm93cywgcHJvcGVydHksIGZhbHNlLCByb3cpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cyA9IFtdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIHJvdyBpcyBzZWxlY3RlZFxyXG5cdFx0XHRcdFx0aWYgKCFzZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0XHRldmVudE5hbWUgPSAnc2VsZWN0JztcclxuXHRcdFx0XHRcdFx0Ly8gYWRkIHJvdyB0byBzZWxlY3RlZCByb3dzXHJcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLnB1c2gocm93KTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmd0T3B0aW9ucy5sYXp5TG9hZCAmJiB0aGlzLmxhenlBbGxTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMubGF6eUFsbFNlbGVjdGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2Rlc2VsZWN0JztcclxuXHRcdFx0XHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHNlbGVjdGVkIHJvd3MuLi5cclxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkUm93cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHNlbGVjdGVkIHJvdyBlcXVhbHMgcGFzc2VkIHJvdy4uLlxyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlbGVjdGVkUm93c1tpXS4kJGd0Um93SWQgPT09IHJvdy4kJGd0Um93SWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLnJlbW92ZSByb3cgZnJvbSBzZWxlY3RlZCByb3dzLi4uXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cy5zcGxpY2UoaSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGV4aXQgbG9vcFxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRldmVudFZhbHVlID0ge1xyXG5cdFx0XHRcdFx0XHRzZWxlY3RlZFJvd3M6IHRoaXMuc2VsZWN0ZWRSb3dzLFxyXG5cdFx0XHRcdFx0XHRjaGFuZ2VkUm93OiByb3dcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaXNVcGRhdGVkJzpcclxuXHRcdFx0XHRcdGV2ZW50TmFtZSA9ICd1cGRhdGVkJztcclxuXHRcdFx0XHRcdGNvbnN0IG9sZFZhbHVlID0gcHJvcGVydHlWYWx1ZXM7XHJcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBlZGl0IG9iamVjdCBleGlzdHMgZm9yIHJvd1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV0gPSB7XHJcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZTogb2xkVmFsdWUsXHJcblx0XHRcdFx0XHRcdFx0b2xkVmFsdWU6IG9sZFZhbHVlLFxyXG5cdFx0XHRcdFx0XHRcdG5ld1ZhbHVlOiByb3dcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldLm9sZFZhbHVlID0gb2xkVmFsdWU7XHJcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldLm5ld1ZhbHVlID0gcm93O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZXZlbnRWYWx1ZSA9IHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldO1xyXG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdFx0XHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbChyb3cpO1xyXG5cdFx0XHRcdFx0Ly8gdGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGEubWFwKChyKSA9PiB7IHJldHVybnsuLi5yfTsgfSldO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xyXG5cdFx0XHRcdG5hbWU6ICdndC1yb3ctJyArIGV2ZW50TmFtZSxcclxuXHRcdFx0XHR2YWx1ZTogZXZlbnRWYWx1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKHByb3BlcnR5ICE9PSAnaXNVcGRhdGVkJykge1xyXG5cdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldID0gIXRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bXHJcblx0XHRcdFx0XHRwcm9wZXJ0eVxyXG5cdFx0XHRcdF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBjb2x1bW4uXHJcblx0ICogQHBhcmFtICRldmVudCAtIGtleSB1cCBldmVudC5cclxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdC5cclxuXHQgKiBAcGFyYW0gY29sdW1uIC0gY29sdW1uIG9iamVjdC5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ3RVcGRhdGVDb2x1bW4oXHJcblx0XHQkZXZlbnQ6IEtleWJvYXJkRXZlbnQsXHJcblx0XHRyb3c6IEd0Um93LFxyXG5cdFx0Y29sdW1uOiBHdFJlbmRlckZpZWxkPGFueSwgYW55PlxyXG5cdCkge1xyXG5cdFx0dGhpcy5fZWRpdFJvdyhyb3csIGNvbHVtbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEcm9wZG93biBzZWxlY3QuXHJcblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QuXHJcblx0ICogQHBhcmFtIGNvbHVtbiAtIGNvbHVtbiBvYmplY3QuXHJcblx0ICovXHJcblx0cHVibGljIGd0RHJvcGRvd25TZWxlY3Qocm93OiBHdFJvdywgY29sdW1uOiBHdFJlbmRlckZpZWxkPGFueSwgYW55Pikge1xyXG5cdFx0Y29uc3Qgb2xkVmFsdWUgPSB7IC4uLnJvdyB9O1xyXG5cdFx0cm93W2NvbHVtbi5vYmplY3RLZXldID0gY29sdW1uLnJlbmRlclZhbHVlO1xyXG5cdFx0dGhpcy51cGRhdGVSb3cocm93LCBvbGRWYWx1ZSk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIF9lZGl0Um93KHJvdzogR3RSb3csIGNvbHVtbjogR3RSZW5kZXJGaWVsZDxhbnksIGFueT4pIHtcclxuXHRcdGNvbnN0IE9CSkVDVF9LRVkgPSBjb2x1bW4ub2JqZWN0S2V5OyAvLyBkZWNsYXJlIG9iamVjdCBrZXkgd2hpY2ggY29udGFpbnMgY2hhbmdlc1xyXG5cclxuXHRcdC8vIGNoZWNrIGlmIGNlbGwgaGFzIGNoYW5nZWQgdmFsdWVcclxuXHRcdGNvbHVtbi5lZGl0ZWQgPSByb3dbY29sdW1uLm9iamVjdEtleV0gIT09IGNvbHVtbi5yZW5kZXJWYWx1ZTtcclxuXHRcdC8vIGNoZWNrIGlmIHJvdyBjb250YWlucyBjaGFuZ2VzLi4uXHJcblx0XHRpZiAoIXRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXSkge1xyXG5cdFx0XHQvLyBpZiBub3QsIGNyZWF0ZSBhbiBvYmplY3QgZm9yIHRoZSBjaGFuZ2VkIHJvd1xyXG5cdFx0XHR0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0gPSB7XHJcblx0XHRcdFx0Y2hhbmdlczoge30sIC8vIGNyZWF0ZSBwbGFjZWhvbGRlciBmb3IgY2hhbmdlc1xyXG5cdFx0XHRcdHJvdzogcm93IC8vIHN0b3JlIHJlZmVyZW5jZSB0byB0aGUgcm93IHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWRcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzdG9yZSBjaGFuZ2VkIGNvbHVtbiB1bmRlciBjaGFuZ2VzIGlmIGl0IGhhcyBiZWVuIGVkaXRlZFxyXG5cdFx0aWYgKGNvbHVtbi5lZGl0ZWQpIHtcclxuXHRcdFx0dGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdLmNoYW5nZXNbT0JKRUNUX0tFWV0gPSBjb2x1bW47XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBkZWxldGUgY2hhbmdlIG9iamVjdCBpZiBjb2x1bW4gaXMgdW5jaGFuZ2VkXHJcblx0XHRcdGRlbGV0ZSB0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0uY2hhbmdlc1tPQkpFQ1RfS0VZXTtcclxuXHRcdFx0Ly8gY2hlY2sgaG93IG1hbnkgY29sdW1ucyBoYXZlIGJlZW4gY2hhbmdlZFxyXG5cdFx0XHRjb25zdCBDSEFOR0VEX0NPTFVNTlMgPSBPYmplY3Qua2V5cyhcclxuXHRcdFx0XHR0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0uY2hhbmdlc1xyXG5cdFx0XHQpLmxlbmd0aDtcclxuXHRcdFx0aWYgKENIQU5HRURfQ09MVU1OUyA9PT0gMCkge1xyXG5cdFx0XHRcdC8vIGRlbGV0ZSByb3cgZnJvbSBlZGl0ZWQgcm93cyBpZiBubyBjb2x1bW5zIGhhdmUgYmVlbiBlZGl0ZWRcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBpZiBubyBsaXN0ZW5lciBpcyBwcmVzZW50Li4uXHJcblx0XHRpZiAoIXRoaXMuZ2xvYmFsSW5saW5lRWRpdExpc3RlbmVyKSB7XHJcblx0XHRcdC8vIC4uLmxpc3RlbiBmb3IgdXBkYXRlIGV2ZW50XHJcblx0XHRcdHRoaXMuX2xpc3RlbkZvcktleWRvd25FdmVudCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvKipcclxuXHQgKiBMaXN0ZW4gZm9yIGtleSBkb3duIGV2ZW50IC0gbGlzdGVuIGZvciBrZXkgZG93biBldmVudCBkdXJpbmcgaW5saW5lIGVkaXQuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBfbGlzdGVuRm9yS2V5ZG93bkV2ZW50KCkge1xyXG5cdFx0Ly8gYWRkIGdsb2JhbCBsaXN0ZW5lciBmb3Iga2V5IGRvd24gZXZlbnRzXHJcblx0XHR0aGlzLmdsb2JhbElubGluZUVkaXRMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKFxyXG5cdFx0XHQnZG9jdW1lbnQnLFxyXG5cdFx0XHQna2V5ZG93bicsXHJcblx0XHRcdCRldmVudCA9PiB7XHJcblx0XHRcdFx0c3dpdGNoICgkZXZlbnQua2V5KSB7XHJcblx0XHRcdFx0XHRjYXNlICdFbnRlcic6IC8vIHVwZGF0ZSBkYXRhIG9iamVjdFxyXG5cdFx0XHRcdFx0XHR0aGlzLmlubGluZUVkaXRVcGRhdGUoKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdFc2NhcGUnOiAvLyBjYW5jZWxcclxuXHRcdFx0XHRcdFx0dGhpcy5pbmxpbmVFZGl0Q2FuY2VsKCk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9XHJcblx0LyoqXHJcblx0ICogSW5saW5lIGVkaXQgdXBkYXRlIC0gYWNjZXB0IGNoYW5nZXMgYW5kIHVwZGF0ZSByb3cgdmFsdWVzLlxyXG5cdCAqL1xyXG5cdHB1YmxpYyBpbmxpbmVFZGl0VXBkYXRlKCkge1xyXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHJvd3MgdGhhdCBoYXZlIGJlZW4gZWRpdGVkXHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLmVkaXRlZFJvd3MpLm1hcChrZXkgPT4ge1xyXG5cdFx0XHRjb25zdCBST1cgPSB0aGlzLmVkaXRlZFJvd3Nba2V5XS5yb3c7IC8vIHJvdyB0byB1cGRhdGVcclxuXHRcdFx0Y29uc3QgQ0hBTkdFUyA9IHRoaXMuZWRpdGVkUm93c1trZXldLmNoYW5nZXM7IC8vIGNoYW5nZXMgdG8gdGhlIHJvd1xyXG5cclxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGNoYW5nZXMgaW4gcm93XHJcblx0XHRcdE9iamVjdC5rZXlzKENIQU5HRVMpLm1hcChvYmplY3RLZXkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG9sZFZhbHVlID0geyAuLi5ST1cgfTtcclxuXHRcdFx0XHRST1dbb2JqZWN0S2V5XSA9IENIQU5HRVNbb2JqZWN0S2V5XS5yZW5kZXJWYWx1ZTsgLy8gdXBkYXRlIGRhdGEgdmFsdWVcclxuXHRcdFx0XHR0aGlzLnVwZGF0ZVJvdyhST1csIG9sZFZhbHVlKTsgLy8gdXBkYXRlIG1ldGEgaW5mbyBmb3Igcm93IGFuZCBzZW5kIGV2ZW50XHJcblx0XHRcdFx0Q0hBTkdFU1tvYmplY3RLZXldLmVkaXRlZCA9IGZhbHNlOyAvLyBkaXNhYmxlIGVkaXQgbW9kZVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0Ly8gY2xlYXIgcm93cyBtYXJrZWQgYXMgZWRpdGVkIGFzIHRoZSByb3dzIGhhdmUgYmVlbiB1cGRhdGVkXHJcblx0XHR0aGlzLmVkaXRlZFJvd3MgPSB7fTtcclxuXHRcdC8vIHJlbW92ZSBsaXN0ZW5lclxyXG5cdFx0dGhpcy5fc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpO1xyXG5cdH1cclxuXHQvKipcclxuXHQgKiBJbmxpbmUgZWRpdCBjYW5jZWwgLSBjYW5jZWwgYW5kIHJlc2V0IGlubGluZSBlZGl0cy5cclxuXHQgKi9cclxuXHRwdWJsaWMgaW5saW5lRWRpdENhbmNlbChyb3c/OiBHdFJvdykge1xyXG5cdFx0aWYgKHJvdykge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdO1xyXG5cdFx0XHQvLyByZW1vdmUgbGlzdGVuZXJcclxuXHRcdFx0dGhpcy5fc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHJvd3MgdGhhdCBoYXZlIGJlZW4gZWRpdGVkXHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLmVkaXRlZFJvd3MpLm1hcChrZXkgPT4ge1xyXG5cdFx0XHRjb25zdCBST1cgPSB0aGlzLmVkaXRlZFJvd3Nba2V5XS5yb3c7IC8vIHJvdyB0byB1cGRhdGVcclxuXHRcdFx0Y29uc3QgQ0hBTkdFUyA9IHRoaXMuZWRpdGVkUm93c1trZXldLmNoYW5nZXM7IC8vIGNoYW5nZXMgdG8gdGhlIHJvd1xyXG5cclxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGNoYW5nZXMgaW4gcm93XHJcblx0XHRcdE9iamVjdC5rZXlzKENIQU5HRVMpLm1hcChvYmplY3RLZXkgPT4ge1xyXG5cdFx0XHRcdENIQU5HRVNbb2JqZWN0S2V5XS5yZW5kZXJWYWx1ZSA9IFJPV1tvYmplY3RLZXldOyAvLyByZXNldCByZW5kZXJlZCB2YWx1ZVxyXG5cdFx0XHRcdENIQU5HRVNbb2JqZWN0S2V5XS5lZGl0ZWQgPSBmYWxzZTsgLy8gZGlzYWJsZSBlZGl0IG1vZGVcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdC8vIGNsZWFyIHJvd3MgbWFya2VkIGFzIGVkaXRlZCBhcyB0aGUgcm93cyBoYXZlIGJlZW4gdXBkYXRlZFxyXG5cdFx0dGhpcy5lZGl0ZWRSb3dzID0ge307XHJcblx0XHQvLyByZW1vdmUgbGlzdGVuZXJcclxuXHRcdHRoaXMuX3N0b3BMaXN0ZW5pbmdGb3JLZXlkb3duRXZlbnQoKTtcclxuXHR9XHJcblx0LyoqXHJcblx0ICogU3RvcCBsaXN0ZW5pbmcgZm9yIGtleSBkb3duIGV2ZW50IC0gc3RvcCBsaXN0ZW5pbmcgZm9yIGtleSBkb3duIGV2ZW50cyBwYXNzZWQgZHVyaW5nIGlubGluZSBlZGl0LlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgX3N0b3BMaXN0ZW5pbmdGb3JLZXlkb3duRXZlbnQoKSB7XHJcblx0XHRpZiAodGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIpIHtcclxuXHRcdFx0dGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIoKTtcclxuXHRcdFx0dGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQXBwbHkgZmlsdGVyKHMpLlxyXG5cdCAqIEBwYXJhbSBmaWx0ZXIgLSBvYmplY3QgY29udGFpbmluZyBrZXkgdmFsdWUgcGFpcnMsIHdoZXJlIHZhbHVlIHNob3VsZCBiZSBhcnJheSBvZiB2YWx1ZXMuXHJcblx0ICovXHJcblx0cHVibGljIGd0QXBwbHlGaWx0ZXIoZmlsdGVyOiBPYmplY3QpIHtcclxuXHRcdHRoaXMuZ3RJbmZvLmZpbHRlciA9IGZpbHRlcjtcclxuXHRcdC8vIGdvIHRvIGZpcnN0IHBhZ2VcclxuXHRcdHRoaXMuZ29Ub1BhZ2UoMSk7XHJcblx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xyXG5cdH1cclxuXHJcblx0LyoqIENsZWFyL3JlbW92ZSBhcHBsaWVkIGZpbHRlcihzKS4gKi9cclxuXHRwdWJsaWMgZ3RDbGVhckZpbHRlcigpIHtcclxuXHRcdHRoaXMuZ3RJbmZvLmZpbHRlciA9IGZhbHNlO1xyXG5cdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcclxuXHRcdC8vIHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNlYXJjaFxyXG5cdCAqIEBwYXJhbSB2YWx1ZSAtIHN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHdvcmRzXHJcblx0ICovXHJcblx0cHVibGljIGd0U2VhcmNoKHZhbHVlOiBzdHJpbmcpIHtcclxuXHRcdHRoaXMuZ3RJbmZvLnNlYXJjaFRlcm1zID0gdmFsdWU7XHJcblx0XHQvLyBhbHdheXMgZ28gdG8gZmlyc3QgcGFnZSB3aGVuIHNlYXJjaGluZ1xyXG5cdFx0dGhpcy5nb1RvUGFnZSgxKTtcclxuXHRcdHRoaXMudXBkYXRlVG90YWxzKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgcm93c1xyXG5cdCAqIEBwYXJhbSByb3dzIC0gcm93cyB0byBhZGRcclxuXHQgKiBAcmV0dXJucyBuZXcgZGF0YSBhcnJheS5cclxuXHQgKi9cclxuXHRwdWJsaWMgZ3RBZGQocm93czogQXJyYXk8Uj4pOiBSZWFkb25seUFycmF5PFI+IHtcclxuXHRcdHRoaXMuZ3REYXRhID0gWy4uLnRoaXMuZ3REYXRhLCAuLi5yb3dzXTtcclxuXHRcdHJldHVybiBbLi4udGhpcy5ndERhdGFdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVsZXRlIHJvd1xyXG5cdCAqIEBwYXJhbSBvYmplY3RLZXkgLSBvYmplY3Qga2V5IHlvdSB3YW50IHRvIGZpbmQgbWF0Y2ggd2l0aFxyXG5cdCAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSBkZWxldGVkXHJcblx0ICogQHBhcmFtIG1hdGNoIC0gYWxsOiBkZWxldGUgYWxsIG1hdGNoZXMsIGZpcnN0OiBkZWxldGUgZmlyc3QgbWF0Y2ggKGRlZmF1bHQpXHJcblx0ICogQHJldHVybnMgbmV3IGRhdGEgYXJyYXkuXHJcblx0ICovXHJcblx0cHVibGljIGd0RGVsZXRlKFxyXG5cdFx0b2JqZWN0S2V5OiBzdHJpbmcsXHJcblx0XHR2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLFxyXG5cdFx0bWF0Y2g6ICdmaXJzdCcgfCAnYWxsJyA9ICdmaXJzdCdcclxuXHQpOiBSZWFkb25seUFycmF5PFI+IHtcclxuXHRcdGlmIChtYXRjaCA9PT0gJ2ZpcnN0Jykge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3REYXRhLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuZ3REYXRhW2ldW29iamVjdEtleV0gPT09IHZhbHVlKSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5pc1Jvd1NlbGVjdGVkKHRoaXMuZ3REYXRhW2ldKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRvZ2dsZVNlbGVjdCh0aGlzLmd0RGF0YVtpXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLmd0RGF0YS5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHR0aGlzLmd0RGF0YSA9IFsuLi50aGlzLmd0RGF0YV07XHJcblx0XHRcdFx0XHRpZiAobWF0Y2ggPT09ICdmaXJzdCcpIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy5ndERhdGEubGVuZ3RoOyBpID4gMDsgaS0tKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuZ3REYXRhW2kgLSAxXVtvYmplY3RLZXldID09PSB2YWx1ZSkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuaXNSb3dTZWxlY3RlZCh0aGlzLmd0RGF0YVtpIC0gMV0pKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMudG9nZ2xlU2VsZWN0KHRoaXMuZ3REYXRhW2kgLSAxXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLmd0RGF0YS5zcGxpY2UoaSAtIDEsIDEpO1xyXG5cdFx0XHRcdFx0dGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFsuLi50aGlzLmd0RGF0YV07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgc3RvcmUgdG8gaG9sZCBwcmV2aW91c2x5IGxvYWRlZCByZWNvcmRzLlxyXG5cdCAqIEBwYXJhbSByZWNvcmRzIC0gdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgaW4gc3RvcmUuXHJcblx0ICogQHBhcmFtIHBlclBhZ2UgLSBob3cgbWFueSByZWNvcmRzIHRvIHNob3cgcGVyIHBhZ2UuXHJcblx0ICogQHJldHVybnMgYSBuZXN0ZWQgYXJyYXkgdG8gaG9sZCByZWNvcmRzIHBlciBwYWdlLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgY3JlYXRlU3RvcmUocmVjb3JkczogbnVtYmVyLCBwZXJQYWdlOiBudW1iZXIpOiBBcnJheTxBcnJheTxhbnk+PiB7XHJcblx0XHRjb25zdCBzdG9yZXMgPSBNYXRoLmNlaWwocmVjb3JkcyAvIHBlclBhZ2UpO1xyXG5cdFx0Y29uc3Qgc3RvcmU6IEFycmF5PEFycmF5PGFueT4+ID0gW107XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlczsgaSsrKSB7XHJcblx0XHRcdHN0b3JlW2ldID0gW107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RvcmU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgcGxhY2Vob2xkZXJzIGZvciByb3dzIHdoaWxlIGxvYWRpbmcgZGF0YSBmcm9tIGJhY2stZW5kLlxyXG5cdCAqIEBwYXJhbSBwZXJQYWdlIC0gaG93IG1hbnkgcmVjb3JkcyB0byBzaG93IHBlciBwYWdlLlxyXG5cdCAqIEByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgZW1wdHkgcmVjb3JkcyB0byBiZSBwcmVzZW50ZWQgd2hpbGUgZmV0Y2hpbmcgcmVhbCBkYXRhLlxyXG5cdCAqL1xyXG5cdHByaXZhdGUgbG9hZGluZ0NvbnRlbnQocGVyUGFnZTogbnVtYmVyKSB7XHJcblx0XHQvLyBjcmVhdGUgcm93IG9iamVjdFxyXG5cdFx0Y29uc3Qgcm93T2JqZWN0OiBPYmplY3QgPSB7XHJcblx0XHRcdCQkbG9hZGluZzogdHJ1ZVxyXG5cdFx0fTtcclxuXHRcdGxldCBvcmRlciA9IDA7XHJcblxyXG5cdFx0Ly8gc29ydCBzZXR0aW5ncyBieSBjb2x1bW4gb3JkZXJcclxuXHRcdHRoaXMuX2d0U2V0dGluZ3Muc29ydCh0aGlzLmdldENvbHVtbk9yZGVyKTtcclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIHNldHRpbmdzIG9iamVjdHMuLi5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCBzZXR0aW5nID0gdGhpcy5fZ3RTZXR0aW5nc1tpXTtcclxuXHJcblx0XHRcdC8vIC4uLmlmIGNvbHVtbiBpcyB2aXNpYmxlIGFuZCBlbmFibGVkLi4uXHJcblx0XHRcdGlmIChzZXR0aW5nLnZpc2libGUgIT09IGZhbHNlICYmIHNldHRpbmcuZW5hYmxlZCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHQvLyAuLi5pZiBmaXJzdCBjb2x1bW4sIHNldCB2YWx1ZSB0byBsb2FkaW5nIHRleHQgb3RoZXJ3aXNlIGxlYXZlIGl0IGVtcHR5XHJcblx0XHRcdFx0aWYgKG9yZGVyID09PSAwKSB7XHJcblx0XHRcdFx0XHRyb3dPYmplY3Rbc2V0dGluZy5vYmplY3RLZXldID0gdGhpcy5ndFRleHRzLmxvYWRpbmc7XHJcblx0XHRcdFx0XHR0aGlzLmxvYWRpbmdQcm9wZXJ0eSA9IHNldHRpbmcub2JqZWN0S2V5O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyb3dPYmplY3Rbc2V0dGluZy5vYmplY3RLZXldID0gJyc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9yZGVyKys7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cm93T2JqZWN0W3NldHRpbmcub2JqZWN0S2V5XSA9ICcnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY3JlYXRlIGNvbnRlbnQgcGxhY2Vob2xkZXJcclxuXHRcdGNvbnN0IGNvbnRlbnRQbGFjZWhvbGRlcjogQXJyYXk8YW55PiA9IFtdO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSBlcXVhbCBudW1iZXIgb2Ygcm93cyBhcyByb3dzIHBlciBwYWdlXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBlclBhZ2U7IGkrKykge1xyXG5cdFx0XHQvLyAuLi5hZGQgdGVtcG9yYXJ5IHJvdyBvYmplY3RcclxuXHRcdFx0Y29udGVudFBsYWNlaG9sZGVyLnB1c2gocm93T2JqZWN0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb250ZW50UGxhY2Vob2xkZXI7XHJcblx0fVxyXG5cclxuXHQvLyBUT0RPOiBtb3ZlIHRvIGhlbHBlciBmdW5jdGlvbnNcclxuXHQvKiogU29ydCBieSBzb3J0IG9yZGVyICovXHJcblx0cHJpdmF0ZSBnZXRTb3J0T3JkZXIgPSBmdW5jdGlvbihhOiBHdENvbmZpZ1NldHRpbmcsIGI6IEd0Q29uZmlnU2V0dGluZykge1xyXG5cdFx0aWYgKGEuc29ydE9yZGVyIDwgYi5zb3J0T3JkZXIpIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEuc29ydE9yZGVyID4gYi5zb3J0T3JkZXIgfHwgdHlwZW9mIGEuc29ydE9yZGVyID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAwO1xyXG5cdH07XHJcblxyXG5cdC8vIFRPRE86IG1vdmUgdG8gaGVscGVyIGZ1bmN0aW9uc1xyXG5cdC8qKiBTb3J0IGJ5IGNvbHVtbiBvcmRlciAqL1xyXG5cdHByaXZhdGUgZ2V0Q29sdW1uT3JkZXIgPSBmdW5jdGlvbihhOiBHdENvbmZpZ1NldHRpbmcsIGI6IEd0Q29uZmlnU2V0dGluZykge1xyXG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5jb2x1bW5PcmRlciA8IGIuY29sdW1uT3JkZXIpIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPiBiLmNvbHVtbk9yZGVyKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fTtcclxuXHJcblx0Ly8gVE9ETzogbW92ZSB0byBoZWxwZXIgZnVuY3Rpb25zXHJcblx0LyoqIENyZWF0ZSBhIGRlZXAgY29weSBvZiBkYXRhICovXHJcblx0cHJpdmF0ZSBjbG9uZURlZXAgPSBmdW5jdGlvbihvOiBhbnkpIHtcclxuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcclxuXHR9O1xyXG5cclxuXHQvKiogRXhwb3J0IGRhdGEgYXMgQ1NWXHJcblx0ICogQHBhcmFtIGZpbGVOYW1lIC0gb3B0aW9uYWwgZmlsZSBuYW1lIChvdmVycmlkZXMgZGVmYXVsdCBmaWxlIG5hbWUpLlxyXG5cdCAqIEBwYXJhbSB1c2VCT00gLSB1c2UgQk9NIChieXRlIG9yZGVyIG1hcmtlcikuXHJcblx0ICovXHJcblx0cHVibGljIGV4cG9ydENTVihmaWxlTmFtZT86IHN0cmluZywgdXNlQk9NOiBib29sZWFuID0gZmFsc2UpIHtcclxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEuZXhwb3J0RGF0YTtcclxuXHRcdGxldCBjc3YgPSAnJztcclxuXHRcdGNvbnN0IEJPTSA9ICdcXHVGRUZGJztcclxuXHJcblx0XHQvLyBjc3YgZXhwb3J0IGhlYWRlcnNcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fZ3RTZXR0aW5nc1tpXS5leHBvcnQgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0Y3N2ICs9IHRoaXMuZ2V0UHJvcGVydHkodGhpcy5fZ3RGaWVsZHMsIHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5KVxyXG5cdFx0XHRcdFx0Lm5hbWU7XHJcblxyXG5cdFx0XHRcdGlmIChpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxKSB7XHJcblx0XHRcdFx0XHRjc3YgKz0gdGhpcy5fZ3RPcHRpb25zLmNzdkRlbGltaXRlcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjc3YgZXhwb3J0IGJvZHlcclxuXHRcdGRhdGEuZm9yRWFjaChyb3cgPT4ge1xyXG5cdFx0XHRjc3YgKz0gJ1xcbic7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ndFNldHRpbmdzW2ldLmV4cG9ydCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdC8vIGdldCBmaWVsZCBzZXR0aW5nc1xyXG5cdFx0XHRcdFx0Y29uc3QgZmllbGRTZXR0aW5nID0gdGhpcy5nZXRQcm9wZXJ0eShcclxuXHRcdFx0XHRcdFx0dGhpcy5fZ3RGaWVsZHMsXHJcblx0XHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5XHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGdldCBleHBvcnQgdmFsdWUsIGlmIGV4cG9ydCBmdW5jdGlvbiBpcyBkZWZpbmVkIHVzZSBpdCBvdGhlcndpc2UgY2hlY2sgZm9yIHZhbHVlIGZ1bmN0aW9uIGFuZCBhcyBhIGxhc3QgcmVzb3J0IGV4cG9ydCByYXcgZGF0YVxyXG5cdFx0XHRcdFx0bGV0IGV4cG9ydFZhbHVlOiBzdHJpbmcgPVxyXG5cdFx0XHRcdFx0XHRmaWVsZFNldHRpbmcuZXhwb3J0ICYmIHR5cGVvZiBmaWVsZFNldHRpbmcuZXhwb3J0ID09PSAnZnVuY3Rpb24nXHJcblx0XHRcdFx0XHRcdFx0PyBmaWVsZFNldHRpbmcuZXhwb3J0KHJvdylcclxuXHRcdFx0XHRcdFx0XHQ6IGZpZWxkU2V0dGluZy52YWx1ZSAmJiB0eXBlb2YgZmllbGRTZXR0aW5nLnZhbHVlID09PSAnZnVuY3Rpb24nXHJcblx0XHRcdFx0XHRcdFx0XHQ/IGZpZWxkU2V0dGluZy52YWx1ZShyb3cpXHJcblx0XHRcdFx0XHRcdFx0XHQ6IHJvd1t0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleV07XHJcblxyXG5cdFx0XHRcdFx0Ly8gZXNjYXBlIGV4cG9ydCB2YWx1ZSB1c2luZyBkb3VibGUgcXVvdGVzIChcIikgaWYgZXhwb3J0IHZhbHVlIGNvbnRhaW5zIGRlbGltaXRlclxyXG5cdFx0XHRcdFx0ZXhwb3J0VmFsdWUgPVxyXG5cdFx0XHRcdFx0XHR0eXBlb2YgZXhwb3J0VmFsdWUgPT09ICdzdHJpbmcnICYmXHJcblx0XHRcdFx0XHRcdGV4cG9ydFZhbHVlLmluZGV4T2YodGhpcy5fZ3RPcHRpb25zLmNzdkRlbGltaXRlcikgIT09IC0xXHJcblx0XHRcdFx0XHRcdFx0PyAnXCInICsgZXhwb3J0VmFsdWUgKyAnXCInXHJcblx0XHRcdFx0XHRcdFx0OiBleHBvcnRWYWx1ZTtcclxuXHJcblx0XHRcdFx0XHRjc3YgKz0gZXhwb3J0VmFsdWU7XHJcblx0XHRcdFx0XHRpZiAoaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRcdFx0XHRjc3YgKz0gdGhpcy5fZ3RPcHRpb25zLmNzdkRlbGltaXRlcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbKHVzZUJPTSA/IEJPTSA6ICcnKSArIGNzdl0sIHtcclxuXHRcdFx0dHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTgnXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAod2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XHJcblx0XHRcdG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKFxyXG5cdFx0XHRcdGJsb2IsXHJcblx0XHRcdFx0ZmlsZU5hbWUgPyBmaWxlTmFtZSArICcuY3N2JyA6IHRoaXMuZ3RUZXh0cy5jc3ZEb3dubG9hZCArICcuY3N2J1xyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuXHRcdFx0bGluay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG5cdFx0XHRpZiAobGluay5kb3dubG9hZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0bGluay5zZXRBdHRyaWJ1dGUoXHJcblx0XHRcdFx0XHQnaHJlZicsXHJcblx0XHRcdFx0XHQnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgK1xyXG5cdFx0XHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoKHVzZUJPTSA/IEJPTSA6ICcnKSArIGNzdilcclxuXHRcdFx0XHQpOyAvLyBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKTtcclxuXHRcdFx0XHRsaW5rLnNldEF0dHJpYnV0ZShcclxuXHRcdFx0XHRcdCdkb3dubG9hZCcsXHJcblx0XHRcdFx0XHRmaWxlTmFtZSA/IGZpbGVOYW1lICsgJy5jc3YnIDogdGhpcy5ndFRleHRzLmNzdkRvd25sb2FkICsgJy5jc3YnXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG5cdFx0XHRcdGxpbmsuY2xpY2soKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjc3YgPSAnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgKyAodXNlQk9NID8gQk9NIDogJycpICsgY3N2O1xyXG5cdFx0XHRcdHdpbmRvdy5vcGVuKGVuY29kZVVSSUNvbXBvbmVudChjc3YpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGVtaXQgZXhwb3J0IGV2ZW50XHJcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XHJcblx0XHRcdG5hbWU6ICdndC1leHBvcnRlZC1jc3YnLFxyXG5cdFx0XHR2YWx1ZTogZmlsZU5hbWUgPyBmaWxlTmFtZSA6IHRoaXMuZ3RUZXh0cy5jc3ZEb3dubG9hZCArICcuY3N2J1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKiogUmV0dXJuIHByb3BlcnR5ICovXHJcblx0cHJpdmF0ZSBnZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKGFycmF5OiBBcnJheTxhbnk+LCBrZXk6IHN0cmluZykge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoYXJyYXlbaV0ub2JqZWN0S2V5ID09PSBrZXkpIHtcclxuXHRcdFx0XHRyZXR1cm4gYXJyYXlbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRwcml2YXRlIHJlc3RydWN0dXJlU29ydGluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0LyoqIENoZWNrIGFuZCBzdG9yZSBzb3J0IG9yZGVyIHVwb24gaW5pdGlhbGl6YXRpb24uXHJcblx0XHQgKiAgVGhpcyBpcyBkb25lIGJ5IGNoZWNraW5nIHNvcnQgcHJvcGVydGllcyBpbiB0aGUgc2V0dGluZ3MgYXJyYXkgb2YgdGhlIHRhYmxlLCBpZiBubyBzb3J0aW5nIGlzIGRlZmluZWRcclxuXHRcdCAqICB3ZSdsbCBzb3J0IHRoZSBkYXRhIGJ5IHRoZSBmaXJzdCB2aXNpYmxlIGFuZCBlbmFibGVkIGNvbHVtbiBpbiB0aGUgdGFibGUoYXNjZW5kaW5nKS4gUGxlYXNlIG5vdGUgdGhhdCBhY3R1YWxseVxyXG5cdFx0ICogIHNvcnRpbmcgaGF2ZSB0byBiZSBkb25lIHNlcnZlciBzaWRlIHdoZW4gbGF6eSBsb2FkaW5nIGRhdGEgZm9yIG9idmlvdXMgcmVhc29ucy4gICovXHJcblx0XHQvLyBjcmVhdGUgc29ydGluZyBhcnJheVxyXG5cdFx0Y29uc3Qgc29ydGluZyA9IFtdO1xyXG5cdFx0aWYgKHRoaXMuX2d0U2V0dGluZ3MpIHtcclxuXHRcdFx0Ly8gLi4uc29ydCBzZXR0aW5ncyBieSBzb3J0IG9yZGVyXHJcblx0XHRcdHRoaXMuX2d0U2V0dGluZ3Muc29ydCh0aGlzLmdldFNvcnRPcmRlcik7XHJcblxyXG5cdFx0XHQvLyAuLi5sb29wIHRocm91Z2ggc2V0dGluZ3NcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2V0dGluZyA9IHRoaXMuX2d0U2V0dGluZ3NbaV07XHJcblxyXG5cdFx0XHRcdC8vIC4uLmlmIHNvcnRlZCBhc2NlbmRpbmcuLi5cclxuXHRcdFx0XHRpZiAoc2V0dGluZy5zb3J0ID09PSAnYXNjJykge1xyXG5cdFx0XHRcdFx0Ly8gLi4uIGFkZCB0byBzb3J0aW5nXHJcblx0XHRcdFx0XHRzb3J0aW5nLnB1c2goc2V0dGluZy5vYmplY3RLZXkpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc2V0dGluZy5zb3J0ID09PSAnZGVzYycpIHtcclxuXHRcdFx0XHRcdC8qIC4uLmVsc2UgaWYgc29ydGVkIGRlc2NlbmRpbmcuLi4gKi8gLy8gLi4uIGFkZCB0byBzb3J0aW5nXHJcblx0XHRcdFx0XHRzb3J0aW5nLnB1c2goJy0nICsgc2V0dGluZy5vYmplY3RLZXkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyAuLi5pZiBubyBzb3J0aW5nIGFwcGxpZWQuLi5cclxuXHRcdFx0aWYgKHNvcnRpbmcubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0c29ydGluZy5wdXNoKCckJGd0Um93SWQnKTtcclxuXHRcdFx0XHQvKi8vIC4uLnNvcnQgc2V0dGluZ3MgYnkgY29sdW1uIG9yZGVyXHJcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5ncy5zb3J0KHRoaXMuZ2V0Q29sdW1uT3JkZXIpO1xyXG5cclxuXHRcdFx0XHQvLyAuLi5sb29wIHRocm91Z2ggc2V0dGluZ3NcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGNvbnN0IHNldHRpbmcgPSB0aGlzLl9ndFNldHRpbmdzW2ldO1xyXG5cclxuXHRcdFx0XHRcdC8vIC4uLmlmIGNvbHVtbiBpcyBlbmFibGVkIGFuZCB2aXNpYmxlLi4uXHJcblx0XHRcdFx0XHRpZiAoc2V0dGluZy5lbmFibGVkICE9PSBmYWxzZSAmJiBzZXR0aW5nLnZpc2libGUgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdC8vIC4uLmFkZCBmaXJzdCBtYXRjaCBhbmQgZXhpdCBmdW5jdGlvblxyXG5cdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlciA9IFt0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleV07XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9Ki9cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLnNvcnRPcmRlci5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dGhpcy5zb3J0T3JkZXIgPSBzb3J0aW5nO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdG5nT25Jbml0KCkge1xyXG5cdFx0Ly8gaWYgbnVtYmVyIG9mIHJvdyB0byBkaXNwbGF5IGZyb20gc3RhcnQgaXMgc2V0IHRvIG51bGwgb3IgMC4uLlxyXG5cdFx0aWYgKCF0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3MpIHtcclxuXHRcdFx0Ly8gLi4uY2hhbmdlIHJvdyBsZW5ndGhcclxuXHRcdFx0dGhpcy5jaGFuZ2VSb3dMZW5ndGgodGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzKTtcclxuXHRcdH1cclxuXHRcdHRoaXMucmVzdHJ1Y3R1cmVTb3J0aW5nKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiAgRXh0ZW5kIG9iamVjdCBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRwcml2YXRlIGV4dGVuZCA9IGZ1bmN0aW9uKGE6IE9iamVjdCwgYjogT2JqZWN0KSB7XHJcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBiKSB7XHJcblx0XHRcdGlmIChiLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0XHRhW2tleV0gPSBiW2tleV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhO1xyXG5cdH07XHJcblxyXG5cdG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuXHRcdC8vIGlmIGd0IHRleHRzIGhhdmUgY2hhbmdlZC4uLlxyXG5cdFx0aWYgKGNoYW5nZXNbJ2d0VGV4dHMnXSkge1xyXG5cdFx0XHQvLyAuLi5leHRlbmQgZ3RPcHRpb25zIGRlZmF1bHQgdmFsdWVzIHdpdGggdmFsdWVzIHBhc3NlZCBpbnRvIGNvbXBvbmVudFxyXG5cdFx0XHR0aGlzLmd0VGV4dHMgPSA8R3RUZXh0cz50aGlzLmV4dGVuZCh0aGlzLmd0RGVmYXVsdFRleHRzLCB0aGlzLmd0VGV4dHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGxhenkgbG9hZGluZyBkYXRhIGFuZCBwYWdpbmcgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlLi4uXHJcblx0XHRpZiAodGhpcy5ndE9wdGlvbnMubGF6eUxvYWQgJiYgdGhpcy5ndEluZm8pIHtcclxuXHRcdFx0Ly8gLi4uY2FsY3VsYXRlIHRvdGFsIG51bWJlciBvZiBwYWdlc1xyXG5cdFx0XHR0aGlzLmd0SW5mby5wYWdlVG90YWwgPSBNYXRoLmNlaWwoXHJcblx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoIC8gdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHQvLyAuLi5kZWNsYXJlIHN0b3JlIHBvc2l0aW9uXHJcblx0XHRcdGNvbnN0IHN0b3JlUG9zaXRpb24gPSB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDE7XHJcblxyXG5cdFx0XHQvLyAuLi5hbmQgaWYgc3RvcmUgaXMgZW1wdHkgb3IgcGFnZSBsZW5ndGggaGFzIGNoYW5nZWQuLi5cclxuXHRcdFx0aWYgKFxyXG5cdFx0XHRcdHRoaXMuc3RvcmUubGVuZ3RoID09PSAwIHx8XHJcblx0XHRcdFx0dGhpcy5zdG9yZVswXS5sZW5ndGggIT09IHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxyXG5cdFx0XHQpIHtcclxuXHRcdFx0XHQvLyAuLi5jcmVhdGUgc3RvcmVcclxuXHRcdFx0XHR0aGlzLnN0b3JlID0gdGhpcy5jcmVhdGVTdG9yZShcclxuXHRcdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaCxcclxuXHRcdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIC4uLnN0b3JlIHJldHJpZXZlZCBkYXRhIGluIHN0b3JlIGF0IHN0b3JlIHBvc2l0aW9uXHJcblx0XHRcdHRoaXMuc3RvcmVbc3RvcmVQb3NpdGlvbl0gPSB0aGlzLmd0RGF0YTtcclxuXHRcdFx0dGhpcy5ndEluZm8udmlzaWJsZVJlY29yZHMgPSBbLi4udGhpcy5ndERhdGFdOyAvLyBhZGQgdmlzaWJsZSByb3dzXHJcblxyXG5cdFx0XHQvLyByZXBsYWNlIGRhdGEgd2l0aCBzdG9yZVxyXG5cdFx0XHR0aGlzLl9ndERhdGEgPSB0aGlzLnN0b3JlO1xyXG5cdFx0XHR0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy51cGRhdGVSZWNvcmRSYW5nZSgpO1xyXG5cdFx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XHJcblx0XHRcdFx0bmFtZTogJ2d0LWluZm8nLFxyXG5cdFx0XHRcdHZhbHVlOiB0aGlzLmd0SW5mb1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoXHJcblx0XHRcdHRoaXMuX2d0RGF0YSAmJlxyXG5cdFx0XHR0aGlzLl9ndERhdGEubGVuZ3RoID49IDAgJiZcclxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10gJiZcclxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10ucHJldmlvdXNWYWx1ZVxyXG5cdFx0KSB7XHJcblx0XHRcdHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIGlmIChcclxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10gJiZcclxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10uZmlyc3RDaGFuZ2UgJiZcclxuXHRcdFx0dGhpcy5fZ3REYXRhICYmXHJcblx0XHRcdHRoaXMuX2d0RGF0YS5sZW5ndGggPiAwXHJcblx0XHQpIHtcclxuXHRcdFx0dGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0cmFja0J5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogR3RSb3cpIHtcclxuXHRcdHJldHVybiBpdGVtLiQkZ3RSb3dJZDtcclxuXHR9XHJcblxyXG5cdHRyYWNrQnlDb2x1bW5GbihpbmRleDogbnVtYmVyLCBpdGVtOiBHdENvbmZpZ0ZpZWxkPGFueSwgYW55Pikge1xyXG5cdFx0cmV0dXJuIGl0ZW0ub2JqZWN0S2V5O1xyXG5cdH1cclxuXHJcblx0bmdPbkRlc3Ryb3koKSB7XHJcblx0XHQvLyByZW1vdmUgbGlzdGVuZXJcclxuXHRcdHRoaXMuX3N0b3BMaXN0ZW5pbmdGb3JLZXlkb3duRXZlbnQoKTtcclxuXHR9XHJcbn1cclxuIl19